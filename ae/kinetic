Help on CModEFITTree in module eqtools.CModEFIT object:

class CCMMooddEEFFIITTTTrreeee(eqtools.EFIT.EFITTree)
 |  Inherits :py:class:`eqtools.EFIT.EFITTree` class. Machine-specific data
 |  handling class for Alcator C-Mod. Pulls EFIT data from selected MDS tree
 |  and shot, stores as object attributes. Each EFIT variable or set of
 |  variables is recovered with a corresponding getter method. Essential data
 |  for EFIT mapping are pulled on initialization (e.g. psirz grid). Additional
 |  data are pulled at the first request and stored for subsequent usage.
 |  
 |  Intializes C-Mod version of EFITTree object.  Pulls data from MDS tree for 
 |  storage in instance attributes.  Core attributes are populated from the MDS 
 |  tree on initialization.  Additional attributes are initialized as None, 
 |  filled on the first request to the object.
 |  
 |  Args:
 |      shot (integer): C-Mod shot index.
 |  
 |  Keyword Args:
 |      tree (string): Optional input for EFIT tree, defaults to 'ANALYSIS'
 |          (i.e., EFIT data are under \analysis::top.efit.results).
 |          For any string TREE (such as 'EFIT20') other than 'ANALYSIS',
 |          data are taken from \TREE::top.results.
 |      length_unit (string): Sets the base unit used for any quantity whose
 |          dimensions are length to any power. Valid options are:
 |              
 |              ===========  ===========================================================================================
 |              'm'          meters
 |              'cm'         centimeters
 |              'mm'         millimeters
 |              'in'         inches
 |              'ft'         feet
 |              'yd'         yards
 |              'smoot'      smoots
 |              'cubit'      cubits
 |              'hand'       hands
 |              'default'    whatever the default in the tree is (no conversion is performed, units may be inconsistent)
 |              ===========  ===========================================================================================
 |              
 |          Default is 'm' (all units taken and returned in meters).
 |      gfile (string): Optional input for EFIT geqdsk location name, 
 |          defaults to 'g_eqdsk' (i.e., EFIT data are under
 |          \tree::top.results.G_EQDSK)
 |      afile (string): Optional input for EFIT aeqdsk location name,
 |          defaults to 'a_eqdsk' (i.e., EFIT data are under 
 |          \tree::top.results.A_EQDSK)
 |      tspline (Boolean): Sets whether or not interpolation in time is
 |          performed using a tricubic spline or nearest-neighbor
 |          interpolation. Tricubic spline interpolation requires at least
 |          four complete equilibria at different times. It is also assumed
 |          that they are functionally correlated, and that parameters do
 |          not vary out of their boundaries (derivative = 0 boundary
 |          condition). Default is False (use nearest neighbor interpolation).
 |      monotonic (Boolean): Sets whether or not the "monotonic" form of time
 |          window finding is used. If True, the timebase must be monotonically
 |          increasing. Default is False (use slower, safer method).
 |  
 |  Method resolution order:
 |      CModEFITTree
 |      eqtools.EFIT.EFITTree
 |      eqtools.core.Equilibrium
 |      __builtin__.object
 |  
 |  Methods defined here:
 |  
 |  ____iinniitt____(self, shot, tree='ANALYSIS', length_unit='m', gfile='g_eqdsk', afile='a_eqdsk', tspline=False, monotonic=True)
 |  
 |  ggeettFF(self)
 |      returns F=RB_{\Phi}(\Psi), often calculated for grad-shafranov 
 |      solutions.
 |      
 |      Returns:
 |          F (Array): [nt,npsi] array of F=RB_{\Phi}(\Psi)
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFFFPPrriimmee(self)
 |      returns FF' function used for grad-shafranov solutions.
 |      
 |      Returns:
 |          FFprime (Array): [nt,npsi] array of FF' fromgrad-shafranov solution.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFlluuxxPPrreess(self)
 |      returns pressure at flux surface.
 |      
 |      Returns:
 |          p (Array): [nt,npsi] array of pressure on flux surface psi.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFlluuxxVVooll(self, length_unit=3)
 |      returns volume within flux surface.
 |      
 |      Keyword Args:
 |          length_unit (String or 3): unit for plasma volume.  Defaults to 3,
 |              indicating default volumetric unit (typically m^3).
 |      
 |      Returns:
 |          fluxVol (Array): [nt,npsi] array of volume within flux surface.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettMMaacchhiinneeCCrroossssSSeeccttiioonnFFuullll(self)
 |      Pulls C-Mod cross-section data from tree, converts to plottable
 |      vector format for use in other plotting routines
 |      
 |      Returns:
 |          (`x`, `y`)
 |      
 |          * **x** (`Array`) - [n] array of x-values for machine cross-section.
 |          * **y** (`Array`) - [n] array of y-values for machine cross-section.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettPPPPrriimmee(self)
 |      returns plasma pressure gradient as a function of psi.
 |      
 |      Returns:
 |          pprime (Array): [nt,npsi] array of pressure gradient on flux surface 
 |          psi from grad-shafranov solution.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQPPrrooffiillee(self)
 |      returns profile of safety factor q.
 |      
 |      Returns:
 |          qpsi (Array): [nt,npsi] array of q on flux surface psi.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettRRCCeennttrr(self, length_unit=1)
 |      returns EFIT radius where Bcentr evaluated
 |      
 |      Returns:
 |          R: Radial position where Bcent calculated [m]
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettRRLLCCFFSS(self, length_unit=1)
 |      returns R-values of LCFS position.
 |      
 |      Returns:
 |          RLCFS (Array): [nt,n] array of R of LCFS points.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettRRmmiiddPPssii(self, length_unit=1)
 |      returns maximum major radius of each flux surface.
 |      
 |      Keyword Args:
 |          length_unit (String or 1): unit of Rmid.  Defaults to 1, indicating 
 |              the default parameter unit (typically m).
 |      
 |      Returns:
 |          Rmid (Array): [nt,npsi] array of maximum (outboard) major radius of 
 |          flux surface psi.
 |      
 |      Raises:
 |          Value Error: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettZZLLCCFFSS(self, length_unit=1)
 |      returns Z-values of LCFS position.
 |      
 |      Returns:
 |          ZLCFS (Array): [nt,n] array of Z of LCFS points.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from eqtools.EFIT.EFITTree:
 |  
 |  ____ggeettssttaattee____(self)
 |      Used to close out the MDSplus.Tree instance to make this class pickleable.
 |  
 |  ____ssttrr____(self)
 |      string formatting for EFITTree class.
 |  
 |  ggeettAAOOuutt(self, length_unit=1)
 |      returns outboard-midplane minor radius at LCFS.
 |      
 |      Keyword Args:
 |          length_unit (String or 1): unit for minor radius.  Defaults to 1, 
 |              denoting default length unit (typically m).
 |      
 |      Returns:
 |          aOut (Array): [nt] array of LCFS outboard-midplane minor radius.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettAArreeaaLLCCFFSS(self, length_unit=2)
 |      returns LCFS cross-sectional area.
 |      
 |      Keyword Args:
 |          length_unit (String or 2): unit for LCFS area.  Defaults to 2, 
 |              denoting default areal unit (typically m^2).
 |      
 |      Returns:
 |          areaLCFS (Array): [nt] array of LCFS area.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBCCeennttrr(self)
 |      returns EFIT-Vacuum toroidal magnetic field in Tesla at Rcentr
 |      
 |      Returns:
 |          B_cent (Array): [nt] array of B_t at center [T]
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBeettaaPP(self)
 |      returns EFIT-calculated poloidal beta.
 |      
 |      Returns:
 |          BetaP (Array): [nt] array of EFIT-calculated average poloidal beta.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBeettaaTT(self)
 |      returns EFIT-calculated toroidal beta.
 |      
 |      Returns:
 |          BetaT (Array): [nt] array of EFIT-calculated average toroidal beta.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBeettaass(self)
 |      pulls calculated betap, betat, internal inductance
 |      
 |      Returns:
 |          namedtuple containing (betat,betap,Li)
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBppAAvvgg(self)
 |      returns average poloidal field.
 |      
 |      Returns:
 |          BpAvg (Array): [nt] array of average poloidal field.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBttPPllaa(self)
 |      returns on-axis plasma toroidal field.
 |      
 |      Returns:
 |          BtPla (Array): [nt] array of toroidal field including plasma effects.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettBBttVVaacc(self)
 |      Returns vacuum toroidal field on-axis.
 |      
 |      Returns:
 |          BtVac (Array): [nt] array of vacuum toroidal field.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettCCuurrrreennttSSiiggnn(self)
 |      Returns the sign of the current, based on the check in Steve Wolfe's 
 |      IDL implementation efit_rz2psi.pro.
 |      
 |      Returns:
 |          currentSign (Integer): 1 for positive-direction current, -1 for negative.
 |  
 |  ggeettDDiiaammaagg(self)
 |      pulls diamagnetic flux measurements, toroidal and poloidal beta, 
 |      energy confinement time and stored energy.
 |      
 |      Returns:
 |          namedtuple containing (diamag. flux, betatd, betapd, tauDiamag, WDiamag)
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettDDiiaammaaggBBeettaaPP(self)
 |      returns diamagnetic-loop avg poloidal beta.
 |      
 |      Returns:
 |          BetaP (Array): [nt] array of measured poloidal beta.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettDDiiaammaaggBBeettaaTT(self)
 |      returns diamagnetic-loop toroidal beta.
 |      
 |      Returns:
 |          BetaT (Array): [nt] array of measured toroidal beta.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettDDiiaammaaggFFlluuxx(self)
 |      returns measured diamagnetic-loop flux.
 |      
 |      Returns:
 |          Flux (Array): [nt] array of diamagnetic-loop flux.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettDDiiaammaaggTTaauuEE(self)
 |      returns diamagnetic-loop energy confinement time.
 |      
 |      Returns:
 |          tauE (Array): [nt] array of measured energy confinement time.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettDDiiaammaaggWWpp(self)
 |      returns diamagnetic-loop plasma stored energy.
 |      
 |      Returns:
 |          Wp (Array): [nt] array of measured plasma stored energy.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettEElloonnggaattiioonn(self)
 |      returns LCFS elongation.
 |      
 |      Returns:
 |          kappa (Array): [nt] array of LCFS elongation.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettEEnneerrggyy(self)
 |      pulls EFIT-calculated energy parameters - stored energy, tau_E, 
 |      injected power, d/dt of magnetic and plasma stored energy.
 |      
 |      Returns:
 |          namedtuple containing (WMHD,tauMHD,Pinj,Wbdot,Wpdot)
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFiieellddss(self)
 |      pulls vacuum and plasma toroidal field, avg poloidal field.
 |      
 |      Returns:
 |          namedtuple containing (btaxv,btaxp,bpolav).
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFlluuxxAAxxiiss(self)
 |      returns psi on magnetic axis.
 |      
 |      Returns:
 |          psiAxis (Array): [nt] array of psi on magnetic axis.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFlluuxxGGrriidd(self)
 |      returns EFIT flux grid.
 |      
 |      Note that this method preserves whatever sign convention is used in the
 |      tree. For C-Mod, this means that the result should be multiplied by
 |      -1 * :py:meth:`getCurrentSign()` in most cases.
 |      
 |      Returns:
 |          psiRZ (Array): [nt,nz,nr] array of (non-normalized) flux on grid.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettFFlluuxxLLCCFFSS(self)
 |      returns psi at separatrix.
 |      
 |      Returns:
 |          psiLCFS (Array): [nt] array of psi at LCFS.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettGGeeoommeettrryy(self, length_unit=None)
 |      pulls dimensional geometry parameters.
 |      
 |      Returns:
 |          namedtuple containing (magR,magZ,areaLCFS,aOut,RmidOut)
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettIInnffoo(self)
 |      returns namedtuple of shot information
 |      
 |      Returns:
 |          namedtuple containing
 |              
 |              =====   ===============================
 |              shot    C-Mod shot index (long)
 |              tree    EFIT tree (string)
 |              nr      size of R-axis for spatial grid
 |              nz      size of Z-axis for spatial grid
 |              nt      size of timebase for flux grid
 |              =====   ===============================
 |  
 |  ggeettIIppCCaallcc(self)
 |      returns EFIT-calculated plasma current.
 |      
 |      Returns:
 |          IpCalc (Array): [nt] array of EFIT-reconstructed plasma current.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettIIppMMeeaass(self)
 |      returns magnetics-measured plasma current.
 |      
 |      Returns:
 |          IpMeas (Array): [nt] array of measured plasma current.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettJJpp(self)
 |      returns EFIT-calculated plasma current density Jp on flux grid.
 |      
 |      Returns:
 |          Jp (Array): [nt,nz,nr] array of current density.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettLLii(self)
 |      returns EFIT-calculated internal inductance.
 |      
 |      Returns:
 |          Li (Array): [nt] array of EFIT-calculated internal inductance.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettLLoowweerrTTrriiaanngguullaarriittyy(self)
 |      returns LCFS lower triangularity.
 |      
 |      Returns:
 |          deltal (Array): [nt] array of LCFS lower triangularity.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettMMaacchhiinneeCCrroossssSSeeccttiioonn(self)
 |      Returns R,Z coordinates of vacuum-vessel wall for masking, plotting 
 |      routines.
 |      
 |      Returns:
 |          (`R_limiter`, `Z_limiter`)
 |      
 |          * **R_limiter** (`Array`) - [n] array of x-values for machine cross-section.
 |          * **Z_limiter** (`Array`) - [n] array of y-values for machine cross-section.
 |  
 |  ggeettMMaaggRR(self, length_unit=1)
 |      returns magnetic-axis major radius.
 |      
 |      Returns:
 |          magR (Array): [nt] array of major radius of magnetic axis.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettMMaaggZZ(self, length_unit=1)
 |      returns magnetic-axis Z.
 |      
 |      Returns:
 |          magZ (Array): [nt] array of Z of magnetic axis.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettPPaarraamm(self, path)
 |      Backup function, applying a direct path input for tree-like data 
 |      storage access for parameters not typically found in 
 |      :py:class:`Equilbrium <eqtools.core.Equilbrium>` object.  
 |      Directly calls attributes read from g/a-files in copy-safe manner.
 |      
 |      Args:
 |          name (String): Parameter name for value stored in EqdskReader 
 |              instance.
 |      
 |      Raises:
 |          AttributeError: raised if no attribute is found.
 |  
 |  ggeettPPiinnjj(self)
 |      returns EFIT-calculated injected power.
 |      
 |      Returns:
 |          Pinj (Array): [nt] array of EFIT-reconstructed injected power.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQ00(self)
 |      returns q on magnetic axis,q0.
 |      
 |      Returns:
 |          q0 (Array): [nt] array of q(psi=0).
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQ11SSuurrff(self, length_unit=1)
 |      returns outboard-midplane minor radius of q=1 surface.
 |      
 |      Keyword Args:
 |          length_unit (String or 1): unit for minor radius.  Defaults to 1, 
 |              denoting default length unit (typically m).
 |      
 |      Returns:
 |          qr1 (Array): [nt] array of minor radius of q=1 surface.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQ22SSuurrff(self, length_unit=1)
 |      returns outboard-midplane minor radius of q=2 surface.
 |      
 |      Keyword Args:
 |          length_unit (String or 1): unit for minor radius.  Defaults to 1, 
 |              denoting default length unit (typically m).
 |      
 |      Returns:
 |          qr2 (Array): [nt] array of minor radius of q=2 surface.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQ33SSuurrff(self, length_unit=1)
 |      returns outboard-midplane minor radius of q=3 surface.
 |      
 |      Keyword Args:
 |          length_unit (String or 1): unit for minor radius.  Defaults to 1, 
 |              denoting default length unit (typically m).
 |      
 |      Returns:
 |          qr3 (Array): [nt] array of minor radius of q=3 surface.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQ9955(self)
 |      returns q at 95% flux surface.
 |      
 |      Returns:
 |          q95 (Array): [nt] array of q(psi=0.95).
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQLLCCFFSS(self)
 |      returns q on LCFS (interpolated).
 |      
 |      Returns:
 |          qLCFS (Array): [nt] array of q* (interpolated).
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettQQss(self, length_unit=1)
 |      pulls q values.
 |      
 |      Returns:
 |          namedtuple containing (q0,q95,qLCFS,rq1,rq2,rq3).
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettRRGGrriidd(self, length_unit=1)
 |      returns EFIT R-axis.
 |      
 |      Returns:
 |          rGrid (Array): [nr] array of R-axis of flux grid.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettRRmmiiddOOuutt(self, length_unit=1)
 |      returns outboard-midplane major radius.
 |      
 |      Keyword Args:
 |          length_unit (String or 1): unit for major radius.  Defaults to 1, 
 |              denoting default length unit (typically m).
 |      
 |      Returns:
 |          RmidOut (Array): [nt] array of major radius of LCFS.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettSShhaappiinngg(self)
 |      pulls LCFS elongation and upper/lower triangularity.
 |      
 |      Returns:
 |          namedtuple containing (kappa, delta_u, delta_l)
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettTTaauuMMHHDD(self)
 |      returns EFIT-calculated MHD energy confinement time.
 |      
 |      Returns:
 |          tauMHD (Array): [nt] array of EFIT-calculated energy confinement time.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettTTiimmeeBBaassee(self)
 |      returns EFIT time base vector.
 |      
 |      Returns:
 |          time (array): [nt] array of time points.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettUUppppeerrTTrriiaanngguullaarriittyy(self)
 |      returns LCFS upper triangularity.
 |      
 |      Returns:
 |          deltau (Array): [nt] array of LCFS upper triangularity.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettVVoollLLCCFFSS(self, length_unit=3)
 |      returns volume within LCFS.
 |      
 |      Keyword Args:
 |          length_unit (String or 3): unit for LCFS volume.  Defaults to 3, 
 |              denoting default volumetric unit (typically m^3).
 |      
 |      Returns:
 |          volLCFS (Array): [nt] array of volume within LCFS.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettWWMMHHDD(self)
 |      returns EFIT-calculated MHD stored energy.
 |      
 |      Returns:
 |          WMHD (Array): [nt] array of EFIT-calculated stored energy.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettWWbbddoott(self)
 |      returns EFIT-calculated d/dt of magnetic stored energy.
 |      
 |      Returns:
 |          dWdt (Array): [nt] array of d(Wb)/dt
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettWWppddoott(self)
 |      returns EFIT-calculated d/dt of plasma stored energy.
 |      
 |      Returns:
 |          dWdt (Array): [nt] array of d(Wp)/dt
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  ggeettZZGGrriidd(self, length_unit=1)
 |      returns EFIT Z-axis.
 |      
 |      Returns:
 |          zGrid (Array): [nz] array of Z-axis of flux grid.
 |      
 |      Raises:
 |          ValueError: if module cannot retrieve data from MDS tree.
 |  
 |  rreemmaappLLCCFFSS(self, mask=False)
 |      Overwrites RLCFS, ZLCFS values pulled from EFIT with 
 |      explicitly-calculated contour of psinorm=1 surface.  This is then masked 
 |      down by the limiter array using core.inPolygon, restricting the contour 
 |      to the closed plasma surface and the divertor legs.
 |      
 |      Keyword Args:
 |          mask (Boolean): Default False.  Set True to mask LCFS path to 
 |              limiter outline (using inPolygon).  Set False to draw full 
 |              contour of psi = psiLCFS.
 |      
 |      Raises:
 |          NotImplementedError: if :py:mod:`matplotlib.pyplot` is not loaded.
 |          ValueError: if limiter outline is not available.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from eqtools.core.Equilibrium:
 |  
 |  FFnnoorrmm22ppssiinnoorrmm(self, F, t, **kwargs)
 |      Calculates the psinorm (normalized poloidal flux) corresponding to the passed normalized flux function :math:`F=RB_{\phi}` values.
 |      
 |      This is provided as a convenience method to plot current lines with the
 |      correct spacing: current lines launched from a grid uniformly-spaced in
 |      Fnorm will have spacing directly proportional to the magnitude.
 |      
 |      By default, EFIT only computes this inside the LCFS. Furthermore, it is
 |      truncated at the radius at which is becomes non-monotonic.
 |      
 |      Args:
 |          F (Array-like or scalar float): Values of F to map to psinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of psinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `F` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `F` or be a
 |              scalar. Default is True (evaluate ALL `volnorm` at EACH element
 |              in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`psinorm`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `psinorm` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `psinorm`).
 |      
 |      Returns:
 |          `psinorm` or (`psinorm`, `time_idxs`)
 |          
 |          * **psinorm** (`Array or scalar float`) - The normalized poloidal
 |            flux. If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `psinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value for F=0.7, t=0.26s::
 |          
 |              psinorm_val = Eq_instance.F2psinorm(0.7, 0.26)
 |          
 |          Find psinorm values at F values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              psinorm_arr = Eq_instance.F2psinorm([0.5, 0.7], 0.26)
 |          
 |          Find psinorm values at F=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              psinorm_arr = Eq_instance.F2psinorm(0.5, [0.2, 0.3])
 |          
 |          Find psinorm values at (F, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              psinorm_arr = Eq_instance.F2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ggeettAAOOuuttSSpplliinnee(self, length_unit=1, kind='nearest')
 |      Gets the univariate spline to interpolate a_out as a function of time.
 |      
 |      Keyword Args:
 |          length_unit (String or 1):
 |              Length unit that a_out is returned in. If
 |              a string is given, it must be a valid unit specifier:
 |              
 |                  ==========  ===========
 |                  'm'         meters
 |                  'cm'        centimeters
 |                  'mm'        millimeters
 |                  'in'        inches
 |                  'ft'        feet
 |                  'yd'        yards
 |                  'smoot'     smoots
 |                  'cubit'     cubits
 |                  'hand'      hands
 |                  'default'   meters
 |                  ==========  ===========
 |                  
 |              If `length_unit` is 1 or None, meters are assumed. The default
 |              value is 1 (a_out returned in meters).
 |          kind (String or non-negative int):
 |              Specifies the type of interpolation to be performed in getting
 |              from t to a_out. This is passed to
 |              :py:class:`scipy.interpolate.interp1d`. Valid options are:
 |              'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'
 |              If this keyword is an integer, it specifies the order of spline
 |              to use. See the documentation for interp1d for more details.
 |              Default value is 'cubic' (3rd order spline interpolation) when
 |              `trispline` is True, 'nearest' otherwise.
 |      
 |      Returns:
 |          scipy.interpolate.interp1d to convert from t to a_out.
 |  
 |  ggeettBBttVVaaccSSpplliinnee(self, kind='nearest')
 |      Gets the univariate spline to interpolate BtVac as a function of time.
 |      
 |      Only used if the instance was created with keyword tspline=True.
 |      
 |      Keyword Args:
 |          kind (String or non-negative int):
 |              Specifies the type of interpolation to be performed in getting
 |              from t to BtVac. This is passed to
 |              :py:class:`scipy.interpolate.interp1d`. Valid options are:
 |              'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'
 |              If this keyword is an integer, it specifies the order of spline
 |              to use. See the documentation for interp1d for more details.
 |              Default value is 'cubic' (3rd order spline interpolation) when
 |              `trispline` is True, 'nearest' otherwise.
 |      
 |      Returns:
 |          scipy.interpolate.interp1d to convert from t to BtVac.
 |  
 |  ggeettMMaaggRRSSpplliinnee(self, length_unit=1, kind='nearest')
 |      Gets the univariate spline to interpolate R_mag as a function of time.
 |      
 |      Only used if the instance was created with keyword tspline=True.
 |      
 |      Keyword Args:
 |          length_unit (String or 1):
 |              Length unit that R_mag is returned in. If
 |              a string is given, it must be a valid unit specifier:
 |                  
 |                  =========== ===========
 |                  'm'         meters
 |                  'cm'        centimeters
 |                  'mm'        millimeters
 |                  'in'        inches
 |                  'ft'        feet
 |                  'yd'        yards
 |                  'smoot'     smoots
 |                  'cubit'     cubits
 |                  'hand'      hands
 |                  'default'   meters
 |                  =========== ===========
 |                  
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (R_out returned in meters).
 |          kind (String or non-negative int):
 |              Specifies the type of interpolation to be performed in getting
 |              from t to R_mag. This is passed to
 |              :py:class:`scipy.interpolate.interp1d`. Valid options are:
 |              'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'
 |              If this keyword is an integer, it specifies the order of spline
 |              to use. See the documentation for interp1d for more details.
 |              Default value is 'cubic' (3rd order spline interpolation) when
 |              `trispline` is True, 'nearest' otherwise.
 |      
 |      Returns:
 |          scipy.interpolate.interp1d to convert from t to R_mid.
 |  
 |  ggeettMMaaggZZSSpplliinnee(self, length_unit=1, kind='nearest')
 |      Gets the univariate spline to interpolate Z_mag as a function of time.
 |      
 |      Generated for completeness of the core position calculation when using
 |      tspline = True
 |      
 |      Keyword Args:
 |          length_unit (String or 1):
 |              Length unit that R_mag is returned in. If
 |              a string is given, it must be a valid unit specifier:
 |              
 |                  =========== ===========
 |                  'm'         meters
 |                  'cm'        centimeters
 |                  'mm'        millimeters
 |                  'in'        inches
 |                  'ft'        feet
 |                  'yd'        yards
 |                  'smoot'     smoots
 |                  'cubit'     cubits
 |                  'hand'      hands
 |                  'default'   meters
 |                  =========== ===========
 |                  
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (R_out returned in meters).
 |          kind (String or non-negative int):
 |              Specifies the type of interpolation to be performed in getting
 |              from t to Z_mag. This is passed to
 |              :py:class:`scipy.interpolate.interp1d`. Valid options are:
 |              'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'
 |              If this keyword is an integer, it specifies the order of spline
 |              to use. See the documentation for interp1d for more details.
 |              Default value is 'cubic' (3rd order spline interpolation) when
 |              `trispline` is True, 'nearest' otherwise.
 |      
 |      Returns:
 |          scipy.interpolate.interp1d to convert from t to R_mid.
 |  
 |  ggeettRRmmiiddOOuuttSSpplliinnee(self, length_unit=1, kind='nearest')
 |      Gets the univariate spline to interpolate R_mid_out as a function of time.
 |      
 |      Generated for completeness of the core position calculation when using
 |      tspline = True
 |      
 |      Keyword Args:
 |          length_unit (String or 1):
 |              Length unit that R_mag is returned in. If
 |              a string is given, it must be a valid unit specifier:
 |              
 |                  =========== ===========
 |                  'm'         meters
 |                  'cm'        centimeters
 |                  'mm'        millimeters
 |                  'in'        inches
 |                  'ft'        feet
 |                  'yd'        yards
 |                  'smoot'     smoots
 |                  'cubit'     cubits
 |                  'hand'      hands
 |                  'default'   meters
 |                  =========== ===========
 |                  
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (R_out returned in meters).
 |          kind (String or non-negative int):
 |              Specifies the type of interpolation to be performed in getting
 |              from t to R_mid_out. This is passed to
 |              :py:class:`scipy.interpolate.interp1d`. Valid options are:
 |              'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'
 |              If this keyword is an integer, it specifies the order of spline
 |              to use. See the documentation for interp1d for more details.
 |              Default value is 'cubic' (3rd order spline interpolation) when
 |              `trispline` is True, 'nearest' otherwise.
 |      
 |      Returns:
 |          scipy.interpolate.interp1d to convert from t to R_mid.
 |  
 |  ggffiillee(self, time=None, nw=None, nh=None, shot=None, name=None, tunit='ms', title='EQTOOLS', nbbbs=100)
 |      Generates an EFIT gfile with gfile naming convention
 |                
 |      Keyword Args:
 |          time (scalar float): Time of equilibrium to
 |              generate the gfile from. This will use the specified
 |              spline functionality to do so. Allows for it to be 
 |              unspecified for single-time-frame equilibria.
 |          nw (scalar integer): Number of points in R.
 |              R is the major radius, and describes the 'width' of the 
 |              gfile.
 |          nh (scalar integer): Number of points in Z. In cylindrical
 |              coordinates Z is the height, and nh describes the 'height' 
 |              of the gfile.
 |          shot (scalar integer): The shot numer of the equilibrium.
 |              Used to help generate the gfile name if unspecified.
 |          name (String): Name of the gfile.  If unspecified, will follow
 |              standard gfile naming convention (g+shot.time) under current
 |              python operating directory.  This allows for it to be saved
 |              in other directories, etc.
 |          tunit (String): Specified unit for tin. It can only be 'ms' for
 |              milliseconds or 's' for seconds.
 |          title (String): Title of the gfile on the first line. Name cannot
 |              exceed 10 digits. This is so that the style of the first line
 |              is preserved.
 |          nbbbs (scalar integer): Number of points to define the plasma 
 |              seperatrix within the gfile.  The points are defined equally
 |              spaced in angle about the plasma center.  This will cause the 
 |              x-point to be poorly defined.
 |      
 |      Raises:
 |          ValueError: If title is longer than 10 characters.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class (example
 |          shot number of 1001).
 |          
 |          Generate a gfile at t=0.26s, output of g1001.26::
 |          
 |              Eq_instance.gfile(.26)
 |  
 |  pphhiinnoorrmm22FF(self, phinorm, t, **kwargs)
 |      Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to F.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of F. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`F`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `F` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `F`).
 |      
 |      Returns:
 |          `F` or (`F`, `time_idxs`)
 |          
 |          * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `F`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single F value for phinorm=0.7, t=0.26s::
 |          
 |              F_val = Eq_instance.phinorm2F(0.7, 0.26)
 |          
 |          Find F values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              F_arr = Eq_instance.phinorm2F([0.5, 0.7], 0.26)
 |          
 |          Find F values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              F_arr = Eq_instance.phinorm2F(0.5, [0.2, 0.3])
 |          
 |          Find F values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              F_arr = Eq_instance.phinorm2F([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22FFFFPPrriimmee(self, phinorm, t, **kwargs)
 |      Calculates the flux function :math:`FF'` corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to FFPrime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of FFPrime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`FFPrime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `FFPrime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `FFPrime`).
 |      
 |      Returns:
 |          `FFPrime` or (`FFPrime`, `time_idxs`)
 |          
 |          * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF'`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `FFPrime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single FFPrime value for phinorm=0.7, t=0.26s::
 |          
 |              FFPrime_val = Eq_instance.phinorm2FFPrime(0.7, 0.26)
 |          
 |          Find FFPrime values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              FFPrime_arr = Eq_instance.phinorm2FFPrime([0.5, 0.7], 0.26)
 |          
 |          Find FFPrime values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              FFPrime_arr = Eq_instance.phinorm2FFPrime(0.5, [0.2, 0.3])
 |          
 |          Find FFPrime values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              FFPrime_arr = Eq_instance.phinorm2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22pp(self, phinorm, t, **kwargs)
 |      Calculates the pressure corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to p.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of p. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |      
 |      Returns:
 |          `p` or (`p`, `time_idxs`)
 |          
 |          * **p** (`Array or scalar float`) - The pressure. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `p`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single p value for phinorm=0.7, t=0.26s::
 |          
 |              p_val = Eq_instance.phinorm2p(0.7, 0.26)
 |          
 |          Find p values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              p_arr = Eq_instance.phinorm2p([0.5, 0.7], 0.26)
 |          
 |          Find p values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              p_arr = Eq_instance.phinorm2p(0.5, [0.2, 0.3])
 |          
 |          Find p values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              p_arr = Eq_instance.phinorm2p([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22pppprriimmee(self, phinorm, t, **kwargs)
 |      Calculates the pressure gradient corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to pprime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of pprime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`pprime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `pprime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `pprime`).
 |      
 |      Returns:
 |          `pprime` or (`pprime`, `time_idxs`)
 |          
 |          * **pprime** (`Array or scalar float`) - The pressure gradient. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `pprime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single pprime value for phinorm=0.7, t=0.26s::
 |          
 |              pprime_val = Eq_instance.phinorm2pprime(0.7, 0.26)
 |          
 |          Find pprime values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              pprime_arr = Eq_instance.phinorm2pprime([0.5, 0.7], 0.26)
 |          
 |          Find pprime values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              pprime_arr = Eq_instance.phinorm2pprime(0.5, [0.2, 0.3])
 |          
 |          Find pprime values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              pprime_arr = Eq_instance.phinorm2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22ppssiinnoorrmm(self, phinorm, t, **kwargs)
 |      Calculates the normalized poloidal flux corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to psinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of psinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `psinorm` or (`psinorm`, `time_idxs`)
 |          
 |          * **psinorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `psinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value for phinorm=0.7, t=0.26s::
 |          
 |              psinorm_val = Eq_instance.phinorm2psinorm(0.7, 0.26)
 |          
 |          Find psinorm values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              psinorm_arr = Eq_instance.phinorm2psinorm([0.5, 0.7], 0.26)
 |          
 |          Find psinorm values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              psinorm_arr = Eq_instance.phinorm2psinorm(0.5, [0.2, 0.3])
 |          
 |          Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              psinorm_arr = Eq_instance.phinorm2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22qq(self, phinorm, t, **kwargs)
 |      Calculates the safety factor ("q") corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to q.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of q. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`q`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `q` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `q`).
 |      
 |      Returns:
 |          `q` or (`q`, `time_idxs`)
 |          
 |          * **q** (`Array or scalar float`) - The safety factor ("q"). If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `q`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single q value for phinorm=0.7, t=0.26s::
 |          
 |              q_val = Eq_instance.phinorm2q(0.7, 0.26)
 |          
 |          Find q values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              q_arr = Eq_instance.phinorm2q([0.5, 0.7], 0.26)
 |          
 |          Find q values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              q_arr = Eq_instance.phinorm2q(0.5, [0.2, 0.3])
 |          
 |          Find q values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              q_arr = Eq_instance.phinorm2q([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22rrhhoo(self, method, *args, **kwargs)
 |      Convert the passed (phinorm, t) coordinates into one of several coordinates.
 |      
 |      Args:
 |          method (String): Indicates which coordinates to convert to.
 |              Valid options are:
 |              
 |                  ======= =================================
 |                  psinorm Normalized poloidal flux
 |                  volnorm Normalized volume
 |                  Rmid    Midplane major radius
 |                  r/a     Normalized minor radius
 |                  q       Safety factor
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to rho.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of rho. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `phinorm` or be
 |              a scalar. Default is True (evaluate ALL `phinorm` at EACH element in
 |              `t`).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |          
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Raises:
 |          ValueError: If `method` is not one of the supported values.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at phinorm=0.6, t=0.26s::
 |          
 |              psi_val = Eq_instance.phinorm2rho('psinorm', 0.6, 0.26)
 |          
 |          Find psinorm values at phinorm of 0.6 and 0.8 at the
 |          single time t=0.26s::
 |          
 |              psi_arr = Eq_instance.phinorm2rho('psinorm', [0.6, 0.8], 0.26)
 |          
 |          Find psinorm values at phinorm of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.phinorm2rho('psinorm', 0.6, [0.2, 0.3])
 |          
 |          Find psinorm values at (phinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::
 |          
 |              psi_arr = Eq_instance.phinorm2rho('psinorm', [0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22rrmmiidd(self, *args, **kwargs)
 |      Calculates the mapped outboard midplane major radius corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to Rmid.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of Rmid. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).                        
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).            
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `Rmid` or (`Rmid`, `time_idxs`)
 |          
 |          * **Rmid** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `Rmid`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single Rmid value for phinorm=0.7, t=0.26s::
 |          
 |              Rmid_val = Eq_instance.phinorm2rmid(0.7, 0.26)
 |          
 |          Find Rmid values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              Rmid_arr = Eq_instance.phinorm2rmid([0.5, 0.7], 0.26)
 |          
 |          Find Rmid values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              Rmid_arr = Eq_instance.phinorm2rmid(0.5, [0.2, 0.3])
 |          
 |          Find Rmid values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              Rmid_arr = Eq_instance.phinorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22rrooaa(self, phi_norm, t, **kwargs)
 |      Calculates the normalized minor radius corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to r/a.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of r/a. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `roa` or (`roa`, `time_idxs`)
 |          
 |          * **roa** (`Array or scalar float`) - Normalized midplane minor
 |            radius. If all of the input arguments are scalar, then a scalar
 |            is returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `roa`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single r/a value for phinorm=0.7, t=0.26s::
 |          
 |              roa_val = Eq_instance.phinorm2roa(0.7, 0.26)
 |          
 |          Find r/a values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              roa_arr = Eq_instance.phinorm2roa([0.5, 0.7], 0.26)
 |          
 |          Find r/a values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              roa_arr = Eq_instance.phinorm2roa(0.5, [0.2, 0.3])
 |          
 |          Find r/a values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              roa_arr = Eq_instance.phinorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22vv(self, phinorm, t, **kwargs)
 |      Calculates the flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to v.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of v. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`v`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `v` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `v`).
 |      
 |      Returns:
 |          `v` or (`v`, `time_idxs`)
 |          
 |          * **v** (`Array or scalar float`) - The flux surface volume. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `v`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single v value for phinorm=0.7, t=0.26s::
 |          
 |              v_val = Eq_instance.phinorm2v(0.7, 0.26)
 |          
 |          Find v values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              v_arr = Eq_instance.phinorm2v([0.5, 0.7], 0.26)
 |          
 |          Find v values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              v_arr = Eq_instance.phinorm2v(0.5, [0.2, 0.3])
 |          
 |          Find v values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              v_arr = Eq_instance.phinorm2v([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pphhiinnoorrmm22vvoollnnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized flux surface volume corresponding to the passed phinorm (normalized toroidal flux) values.
 |      
 |      Args:
 |          phinorm (Array-like or scalar float): Values of the normalized
 |              toroidal flux to map to volnorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `phinorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `phinorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of volnorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `phinorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `phinorm`
 |              or be a scalar. Default is True (evaluate ALL `phinorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `volnorm` or (`volnorm`, `time_idxs`)
 |          
 |          * **volnorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `volnorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single volnorm value for phinorm=0.7, t=0.26s::
 |          
 |              volnorm_val = Eq_instance.phinorm2volnorm(0.7, 0.26)
 |          
 |          Find volnorm values at phinorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              volnorm_arr = Eq_instance.phinorm2volnorm([0.5, 0.7], 0.26)
 |          
 |          Find volnorm values at phinorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              volnorm_arr = Eq_instance.phinorm2volnorm(0.5, [0.2, 0.3])
 |          
 |          Find volnorm values at (phinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              volnorm_arr = Eq_instance.phinorm2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  pplloottFFiieelldd(self, t, rhovals=6, rhomin=0.050000000000000003, rhomax=0.94999999999999996, color='b', cmap='plasma', alpha=0.5, arrows=True, linewidth=1.0, arrowlinewidth=3.0, a=None, **kwargs)
 |      Plot the field lines starting from a number of points.
 |      
 |      The field lines are started at the outboard midplane.
 |      
 |      If uniformly-spaced psinorm points are used, the spacing of the magnetic
 |      field lines will be directly proportional to the field strength,
 |      assuming a sufficient number of revolutions is traced.
 |      
 |      Args:
 |          t (float): Time to trace field line at.
 |      
 |      Keyword Args:
 |          rhovals (int or array of int): The number of uniformly-spaced rho
 |              points between `rhomin` and `rhomax` to use, or an explicit grid of rho
 |              points to use. Default is 6.
 |          rhomin (float): The minimum value of rho to use when using a
 |              uniformly-spaced grid. Default is 0.05.
 |          rhomax (float): The maximum value of rho to use when using a
 |              uniformly-spaced grid. Default is 0.95.
 |          color (str): The color to plot the field lines in. Default is 'b'.
 |              If set to 'sequential', each field line will be a different
 |              color, in the sequence matplotlib assigns them. If set to
 |              'magnitude', the coloring will be proportional to the magnitude
 |              of the field. Note that this is very time-consuming, as the
 |              limitations of matplotlib mean that each line segment must be
 |              plotted individually.
 |          cmap (str): The colormap to use when `color` is 'magnitude'. Default
 |              is 'plasma', a perceptually uniform sequential colormap.
 |          alpha (float): The transparency to plot the field lines with.
 |              Default is 0.5.
 |          arrows (bool): If True, an arrowhead indicating the field direction
 |              will be drawn at the start of each field line. Default is True.
 |          linewidth (float): The line width to use when plotting the field
 |              lines. Default is 1.0.
 |          arrowlinewidth (float): The line width to use when plotting the
 |              arrows. Default is 3.0
 |          a (:py:class:`matplotlib.axes._subplots.Axes3DSubplot`): The axes to
 |              plot the field lines on. Default is to make a new figure. Note
 |              that a colorbar will be drawn when `color` is magnitude, but
 |              only if `a` is not provided.
 |          origin ({'psinorm', 'phinorm', 'volnorm', 'r/a', 'Rmid', 'Fnorm'}):
 |              The flux surface coordinates which `rhovals` is given in.
 |              Default is 'psinorm'.
 |          phi0 (float): Toroidal angle of starting point in radians. Default
 |              is 0.0.
 |          field ({'B', 'j'}): The field to use. Can be magnetic field ('B') or
 |              current density ('j'). Default is 'B' (magnetic field).
 |          num_rev (float): The number of revolutions to trace the field line
 |              through. Whether this refers to toroidal or poloidal revolutions
 |              is determined by the `rev_method` keyword. Default is 1.0.
 |          rev_method ('toroidal', 'poloidal'): Whether `num_rev` refers to the
 |              number of toroidal or poloidal revolutions the field line should
 |              make. Note that 'poloidal' only makes sense for close field
 |              lines. Default is 'toroidal'.
 |          dphi (float): Toroidal step size, in radians. Default is 0.02*pi.
 |              The number of steps taken is then 2*pi times the number of
 |              toroidal rotations divided by dphi. This can be negative to
 |              trace a field line clockwise instead of counterclockwise.
 |          integrator (str): The integrator to use with
 |              :py:class:`scipy.integrate.ode`. Default is 'dopri5' (explicit
 |              Dormand-Prince of order (4)5). Can also be an instance of
 |              :py:class:`scipy.integrate.ode` for which the integrator and its
 |              options has been set.
 |      
 |      Returns:
 |          (figure, axis): The figure and axis which the field lines were plotted in.
 |  
 |  pplloottFFlluuxx(self, fill=True, mask=True, lw=3)
 |      Plots flux contours directly from psi grid.
 |      
 |      Returns the Figure instance created and the time slider widget (in case
 |      you need to modify the callback). `f.axes` contains the contour plot as
 |      the first element and the time slice slider as the second element.
 |      
 |      Keyword Args:
 |          fill (Boolean):
 |              Set True to plot filled contours.  Set False (default) to plot white-background
 |              color contours.
 |  
 |  ppssiinnoorrmm22FF(self, psinorm, t, **kwargs)
 |      Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to F.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of F. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`F`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `F` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `F`).
 |      
 |      Returns:
 |          `F` or (`F`, `time_idxs`)
 |          
 |          * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `F`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single F value for psinorm=0.7, t=0.26s::
 |          
 |              F_val = Eq_instance.psinorm2F(0.7, 0.26)
 |              
 |          Find F values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              F_arr = Eq_instance.psinorm2F([0.5, 0.7], 0.26)
 |          
 |          Find F values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              F_arr = Eq_instance.psinorm2F(0.5, [0.2, 0.3])
 |          
 |          Find F values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              F_arr = Eq_instance.psinorm2F([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22FFFFPPrriimmee(self, psinorm, t, **kwargs)
 |      Calculates the flux function :math:`FF'` corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to FFPrime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of FFPrime. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`FFPrime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `FFPrime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `FFPrime`).
 |      
 |      Returns:
 |          `FFPrime` or (`FFPrime`, `time_idxs`)
 |          
 |          * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF'`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `FFPrime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single FFPrime value for psinorm=0.7, t=0.26s::
 |          
 |              FFPrime_val = Eq_instance.psinorm2FFPrime(0.7, 0.26)
 |              
 |          Find FFPrime values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              FFPrime_arr = Eq_instance.psinorm2FFPrime([0.5, 0.7], 0.26)
 |          
 |          Find FFPrime values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              FFPrime_arr = Eq_instance.psinorm2FFPrime(0.5, [0.2, 0.3])
 |          
 |          Find FFPrime values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              FFPrime_arr = Eq_instance.psinorm2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22pp(self, psinorm, t, **kwargs)
 |      Calculates the pressure corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to p.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of p. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |      
 |      Returns:
 |          `p` or (`p`, `time_idxs`)
 |          
 |          * **p** (`Array or scalar float`) - The pressure. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `p`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single p value for psinorm=0.7, t=0.26s::
 |          
 |              p_val = Eq_instance.psinorm2p(0.7, 0.26)
 |              
 |          Find p values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              p_arr = Eq_instance.psinorm2p([0.5, 0.7], 0.26)
 |          
 |          Find p values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              p_arr = Eq_instance.psinorm2p(0.5, [0.2, 0.3])
 |          
 |          Find p values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              p_arr = Eq_instance.psinorm2p([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22pphhiinnoorrmm(self, psi_norm, t, **kwargs)
 |      Calculates the normalized toroidal flux corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to phinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of phinorm. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `phinorm` or (`phinorm`, `time_idxs`)
 |          
 |          * **phinorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `phinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single phinorm value for psinorm=0.7, t=0.26s::
 |          
 |              phinorm_val = Eq_instance.psinorm2phinorm(0.7, 0.26)
 |              
 |          Find phinorm values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              phinorm_arr = Eq_instance.psinorm2phinorm([0.5, 0.7], 0.26)
 |          
 |          Find phinorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              phinorm_arr = Eq_instance.psinorm2phinorm(0.5, [0.2, 0.3])
 |          
 |          Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              phinorm_arr = Eq_instance.psinorm2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22pppprriimmee(self, psinorm, t, **kwargs)
 |      Calculates the pressure gradient corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to pprime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of pprime. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`pprime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `pprime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `pprime`).
 |      
 |      Returns:
 |          `pprime` or (`pprime`, `time_idxs`)
 |          
 |          * **pprime** (`Array or scalar float`) - The pressure gradient. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `pprime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single pprime value for psinorm=0.7, t=0.26s::
 |          
 |              pprime_val = Eq_instance.psinorm2pprime(0.7, 0.26)
 |              
 |          Find pprime values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              pprime_arr = Eq_instance.psinorm2pprime([0.5, 0.7], 0.26)
 |          
 |          Find pprime values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              pprime_arr = Eq_instance.psinorm2pprime(0.5, [0.2, 0.3])
 |          
 |          Find pprime values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              pprime_arr = Eq_instance.psinorm2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22qq(self, psinorm, t, **kwargs)
 |      Calculates the safety factor ("q") corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to q.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of q. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`q`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `q` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `q`).
 |      
 |      Returns:
 |          `q` or (`q`, `time_idxs`)
 |          
 |          * **q** (`Array or scalar float`) - The safety factor ("q"). If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `q`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single q value for psinorm=0.7, t=0.26s::
 |          
 |              q_val = Eq_instance.psinorm2q(0.7, 0.26)
 |              
 |          Find q values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              q_arr = Eq_instance.psinorm2q([0.5, 0.7], 0.26)
 |          
 |          Find q values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              q_arr = Eq_instance.psinorm2q(0.5, [0.2, 0.3])
 |          
 |          Find q values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              q_arr = Eq_instance.psinorm2q([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22rrhhoo(self, method, *args, **kwargs)
 |      Convert the passed (psinorm, t) coordinates into one of several coordinates.
 |      
 |      Args:
 |          method (String): Indicates which coordinates to convert to.
 |              Valid options are:
 |              
 |                  ======= =================================
 |                  phinorm Normalized toroidal flux
 |                  volnorm Normalized volume
 |                  Rmid    Midplane major radius
 |                  r/a     Normalized minor radius
 |                  q       Safety factor
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to rho.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of rho. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |          
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Raises:
 |          ValueError: If `method` is not one of the supported values.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single phinorm value at psinorm=0.6, t=0.26s::
 |          
 |              phi_val = Eq_instance.psinorm2rho('phinorm', 0.6, 0.26)
 |          
 |          Find phinorm values at phinorm of 0.6 and 0.8 at the
 |          single time t=0.26s::
 |          
 |              phi_arr = Eq_instance.psinorm2rho('phinorm', [0.6, 0.8], 0.26)
 |          
 |          Find phinorm values at psinorm of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              phi_arr = Eq_instance.psinorm2rho('phinorm', 0.6, [0.2, 0.3])
 |          
 |          Find phinorm values at (psinorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::
 |          
 |              phi_arr = Eq_instance.psinorm2rho('phinorm', [0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22rrmmiidd(self, psi_norm, t, **kwargs)
 |      Calculates the outboard R_mid location corresponding to the passed psinorm (normalized poloidal flux) values.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to Rmid.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of Rmid. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `Rmid` or (`Rmid`, `time_idxs`)
 |          
 |          * **Rmid** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `Rmid`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single R_mid value for psinorm=0.7, t=0.26s::
 |          
 |              R_mid_val = Eq_instance.psinorm2rmid(0.7, 0.26)
 |          
 |          Find R_mid values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              R_mid_arr = Eq_instance.psinorm2rmid([0.5, 0.7], 0.26)
 |          
 |          Find R_mid values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              R_mid_arr = Eq_instance.psinorm2rmid(0.5, [0.2, 0.3])
 |          
 |          Find R_mid values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              R_mid_arr = Eq_instance.psinorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22rrooaa(self, psi_norm, t, **kwargs)
 |      Calculates the normalized minor radius location corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to r/a.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of r/a. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `roa` or (`roa`, `time_idxs`)
 |      
 |          * **roa** (`Array or scalar float`) - Normalized midplane minor
 |            radius. If all of the input arguments are scalar, then a scalar
 |            is returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `roa`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single r/a value for psinorm=0.7, t=0.26s::
 |          
 |              roa_val = Eq_instance.psinorm2roa(0.7, 0.26)
 |          
 |          Find r/a values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              roa_arr = Eq_instance.psinorm2roa([0.5, 0.7], 0.26)
 |          
 |          Find r/a values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              roa_arr = Eq_instance.psinorm2roa(0.5, [0.2, 0.3])
 |          
 |          Find r/a values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              roa_arr = Eq_instance.psinorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22vv(self, psinorm, t, **kwargs)
 |      Calculates the flux surface volume corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to v.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of v. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`v`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `v` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `v`).
 |      
 |      Returns:
 |          `v` or (`v`, `time_idxs`)
 |          
 |          * **v** (`Array or scalar float`) - The pressure. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `v`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single v value for psinorm=0.7, t=0.26s::
 |          
 |              v_val = Eq_instance.psinorm2v(0.7, 0.26)
 |              
 |          Find v values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              v_arr = Eq_instance.psinorm2v([0.5, 0.7], 0.26)
 |          
 |          Find v values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              v_arr = Eq_instance.psinorm2v(0.5, [0.2, 0.3])
 |          
 |          Find v values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              v_arr = Eq_instance.psinorm2v([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ppssiinnoorrmm22vvoollnnoorrmm(self, psi_norm, t, **kwargs)
 |      Calculates the normalized volume corresponding to the passed psi_norm (normalized poloidal flux) values.
 |      
 |      Args:
 |          psi_norm (Array-like or scalar float): Values of the normalized
 |              poloidal flux to map to volnorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `psi_norm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `psi_norm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of volnorm. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `psi_norm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `psi_norm` or be
 |              a scalar. Default is True (evaluate ALL `psi_norm` at EACH element in
 |              `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `volnorm` or (`volnorm`, `time_idxs`)
 |      
 |          * **volnorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `volnorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single volnorm value for psinorm=0.7, t=0.26s::
 |          
 |              volnorm_val = Eq_instance.psinorm2volnorm(0.7, 0.26)
 |          
 |          Find volnorm values at psi_norm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              volnorm_arr = Eq_instance.psinorm2volnorm([0.5, 0.7], 0.26)
 |          
 |          Find volnorm values at psi_norm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              volnorm_arr = Eq_instance.psinorm2volnorm(0.5, [0.2, 0.3])
 |          
 |          Find volnorm values at (psinorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              volnorm_arr = Eq_instance.psinorm2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrhhoo22FFiieellddLLiinneeTTrraaccee(self, rho, t, origin='psinorm', **kwargs)
 |      Trace a field line starting from a given normalized coordinate point.
 |      
 |      The field line is started at the outboard midplane.
 |      
 |      Args:
 |          rho (float): Flux surface label of starting point.
 |          t (float): Time to trace field line at.
 |      
 |      Keyword Args:
 |          origin ({'psinorm', 'phinorm', 'volnorm', 'r/a', 'Rmid', 'Fnorm'}):
 |              The flux surface coordinates which `rhovals` is given in.
 |              Default is 'psinorm'.
 |          phi0 (float): Toroidal angle of starting point in radians. Default
 |              is 0.0.
 |          field ({'B', 'j'}): The field to use. Can be magnetic field ('B') or
 |              current density ('j'). Default is 'B' (magnetic field).
 |          num_rev (float): The number of revolutions to trace the field line
 |              through. Whether this refers to toroidal or poloidal revolutions
 |              is determined by the `rev_method` keyword. Default is 1.0.
 |          rev_method ('toroidal', 'poloidal'): Whether `num_rev` refers to the
 |              number of toroidal or poloidal revolutions the field line should
 |              make. Note that 'poloidal' only makes sense for close field
 |              lines. Default is 'toroidal'.
 |          dphi (float): Toroidal step size, in radians. Default is 0.02*pi.
 |              The number of steps taken is then 2*pi times the number of
 |              toroidal rotations divided by dphi. This can be negative to
 |              trace a field line clockwise instead of counterclockwise.
 |          integrator (str): The integrator to use with
 |              :py:class:`scipy.integrate.ode`. Default is 'dopri5' (explicit
 |              Dormand-Prince of order (4)5). Can also be an instance of
 |              :py:class:`scipy.integrate.ode` for which the integrator and its
 |              options has been set.
 |      
 |      Returns:
 |          array, (`nsteps` + 1, 3): Containing the (R, Z, phi) coordinates.
 |  
 |  rrhhoo22rrhhoo(self, origin, destination, *args, **kwargs)
 |      Convert from one coordinate to another.
 |      
 |      Args:
 |          origin (String): Indicates which coordinates the data are given in.
 |              Valid options are:
 |              
 |                  ======= ========================
 |                  RZ      R,Z coordinates
 |                  psinorm Normalized poloidal flux
 |                  phinorm Normalized toroidal flux
 |                  volnorm Normalized volume
 |                  Rmid    Midplane major radius
 |                  r/a     Normalized minor radius
 |                  ======= ========================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          destination (String): Indicates which coordinates to convert to.
 |              Valid options are:
 |              
 |                  ======= =================================
 |                  psinorm Normalized poloidal flux
 |                  phinorm Normalized toroidal flux
 |                  volnorm Normalized volume
 |                  Rmid    Midplane major radius
 |                  r/a     Normalized minor radius
 |                  q       Safety factor
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          rho (Array-like or scalar float): Values of the starting coordinate
 |              to map to the new coordinate. Will be two arguments `R`, `Z` if
 |              `origin` is 'RZ'.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `rho`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `rho` (or the meshgrid of `R`
 |              and `Z` if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of `rho`. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `rho` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `rho` or be
 |              a scalar. Default is True (evaluate ALL `rho` at EACH element in
 |              `t`).
 |          make_grid (Boolean): Only applicable if `origin` is 'RZ'. Set to
 |              True to pass `R` and `Z` through :py:func:`scipy.meshgrid`
 |              before evaluating. If this is set to True, `R` and `Z` must each
 |              only have a single dimension, but can have different lengths.
 |              Default is False (do not form meshgrid).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid when `destination` is Rmid. Default is False
 |              (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that quantities are
 |              given/returned in, as applicable. If a string is given, it must
 |              be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |      
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Raises:
 |          ValueError: If `origin` is not one of the supported values.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at r/a=0.6, t=0.26s::
 |          
 |              psi_val = Eq_instance.rho2rho('r/a', 'psinorm', 0.6, 0.26)
 |          
 |          Find psinorm values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s::
 |          
 |              psi_arr = Eq_instance.rho2rho('r/a', 'psinorm', [0.6, 0.8], 0.26)
 |          
 |          Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.rho2rho('r/a', 'psinorm', 0.6, [0.2, 0.3])
 |          
 |          Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              psi_arr = Eq_instance.rho2rho('r/a', 'psinorm', [0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22FF(self, R_mid, t, **kwargs)
 |      Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to F.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of F. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`F`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `F` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `F`).
 |      
 |      Returns:
 |          `F` or (`F`, `time_idxs`)
 |          
 |          * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `F`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single F value for Rmid=0.7m, t=0.26s::
 |          
 |              F_val = Eq_instance.rmid2F(0.7, 0.26)
 |          
 |          Find F values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              F_arr = Eq_instance.rmid2F([0.5, 0.7], 0.26)
 |          
 |          Find F values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              F_arr = Eq_instance.rmid2F(0.5, [0.2, 0.3])
 |          
 |          Find F values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              F_arr = Eq_instance.rmid2F([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22FFFFPPrriimmee(self, R_mid, t, **kwargs)
 |      Calculates the flux function :math:`FF'` corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to FFPrime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of FFPrime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`FFPrime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `FFPrime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `FFPrime`).
 |      
 |      Returns:
 |          `FFPrime` or (`FFPrime`, `time_idxs`)
 |          
 |          * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF'`.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `FFPrime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single FFPrime value for Rmid=0.7m, t=0.26s::
 |          
 |              FFPrime_val = Eq_instance.rmid2FFPrime(0.7, 0.26)
 |          
 |          Find FFPrime values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              FFPrime_arr = Eq_instance.rmid2FFPrime([0.5, 0.7], 0.26)
 |          
 |          Find FFPrime values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              FFPrime_arr = Eq_instance.rmid2FFPrime(0.5, [0.2, 0.3])
 |          
 |          Find FFPrime values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              FFPrime_arr = Eq_instance.rmid2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22pp(self, R_mid, t, **kwargs)
 |      Calculates the pressure corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to p.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of p. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |      
 |      Returns:
 |          `p` or (`p`, `time_idxs`)
 |          
 |          * **p** (`Array or scalar float`) - The pressure.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `p`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single p value for Rmid=0.7m, t=0.26s::
 |          
 |              p_val = Eq_instance.rmid2p(0.7, 0.26)
 |          
 |          Find p values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              p_arr = Eq_instance.rmid2p([0.5, 0.7], 0.26)
 |          
 |          Find p values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              p_arr = Eq_instance.rmid2p(0.5, [0.2, 0.3])
 |          
 |          Find p values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              p_arr = Eq_instance.rmid2p([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22pphhiinnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized toroidal flux.
 |      
 |      Uses the definitions:
 |      
 |      .. math::
 |      
 |          \texttt{phi} &= \int q(\psi)\,d\psi
 |          
 |          \texttt{phi\_norm} &= \frac{\phi}{\phi(a)}
 |          
 |      This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to phinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of phinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `phinorm` or (`phinorm`, `time_idxs`)
 |          
 |          * **phinorm** (`Array or scalar float`) - Normalized toroidal flux.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `phinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single phinorm value at R_mid=0.6m, t=0.26s::
 |          
 |              phi_val = Eq_instance.rmid2phinorm(0.6, 0.26)
 |          
 |          Find phinorm values at R_mid points 0.6m and 0.8m at the single time
 |          t=0.26s::
 |          
 |              phi_arr = Eq_instance.rmid2phinorm([0.6, 0.8], 0.26)
 |          
 |          Find phinorm values at R_mid point 0.6m at times t=[0.2s, 0.3s]::
 |          
 |              phi_arr = Eq_instance.rmid2phinorm(0.6, [0.2, 0.3])
 |          
 |          Find phinorm values at (R, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              phi_arr = Eq_instance.rmid2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22pppprriimmee(self, R_mid, t, **kwargs)
 |      Calculates the pressure gradient corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to pprime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of pprime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`pprime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `pprime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `pprime`).
 |      
 |      Returns:
 |          `pprime` or (`pprime`, `time_idxs`)
 |          
 |          * **pprime** (`Array or scalar float`) - The pressure gradient.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `pprime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single pprime value for Rmid=0.7m, t=0.26s::
 |          
 |              pprime_val = Eq_instance.rmid2pprime(0.7, 0.26)
 |          
 |          Find pprime values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              pprime_arr = Eq_instance.rmid2pprime([0.5, 0.7], 0.26)
 |          
 |          Find pprime values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              pprime_arr = Eq_instance.rmid2pprime(0.5, [0.2, 0.3])
 |          
 |          Find pprime values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              pprime_arr = Eq_instance.rmid2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22ppssiinnoorrmm(self, R_mid, t, **kwargs)
 |      Calculates the normalized poloidal flux corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to psinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of psinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `psinorm` or (`psinorm`, `time_idxs`)
 |          
 |          * **psinorm** (`Array or scalar float`) - Normalized poloidal flux.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `psinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value for Rmid=0.7m, t=0.26s::
 |          
 |              psinorm_val = Eq_instance.rmid2psinorm(0.7, 0.26)
 |          
 |          Find psinorm values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              psinorm_arr = Eq_instance.rmid2psinorm([0.5, 0.7], 0.26)
 |          
 |          Find psinorm values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              psinorm_arr = Eq_instance.rmid2psinorm(0.5, [0.2, 0.3])
 |          
 |          Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              psinorm_arr = Eq_instance.rmid2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22qq(self, R_mid, t, **kwargs)
 |      Calculates the safety factor ("q") corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to q.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of q. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`q`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `q` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `q`).
 |      
 |      Returns:
 |          `q` or (`q`, `time_idxs`)
 |          
 |          * **q** (`Array or scalar float`) - The safety factor ("q").
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `q`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single q value for Rmid=0.7m, t=0.26s::
 |          
 |              q_val = Eq_instance.rmid2q(0.7, 0.26)
 |          
 |          Find q values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              q_arr = Eq_instance.rmid2q([0.5, 0.7], 0.26)
 |          
 |          Find q values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              q_arr = Eq_instance.rmid2q(0.5, [0.2, 0.3])
 |          
 |          Find q values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              q_arr = Eq_instance.rmid2q([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22rrhhoo(self, method, R_mid, t, **kwargs)
 |      Convert the passed (R_mid, t) coordinates into one of several coordinates.
 |      
 |      Args:
 |          method (String): Indicates which coordinates to convert to. Valid
 |              options are:
 |              
 |                  ======= =================================
 |                  psinorm Normalized poloidal flux
 |                  phinorm Normalized toroidal flux
 |                  volnorm Normalized volume
 |                  r/a     Normalized minor radius
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to rho.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of rho. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |      
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at R_mid=0.6m, t=0.26s::
 |          
 |              psi_val = Eq_instance.rmid2rho('psinorm', 0.6, 0.26)
 |          
 |          Find psinorm values at R_mid points 0.6m and 0.8m at the
 |          single time t=0.26s.::
 |          
 |              psi_arr = Eq_instance.rmid2rho('psinorm', [0.6, 0.8], 0.26)
 |          
 |          Find psinorm values at R_mid of 0.6m at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.rmid2rho('psinorm', 0.6, [0.2, 0.3])
 |          
 |          Find psinorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              psi_arr = Eq_instance.rmid2rho('psinorm', [0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22rrooaa(self, R_mid, t, each_t=True, return_t=False, sqrt=False, blob=None, length_unit=1)
 |      Convert the passed (R_mid, t) coordinates into r/a.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to r/a.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of r/a. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `roa` or (`roa`, `time_idxs`)
 |          
 |          * **roa** (`Array or scalar float`) - Normalized midplane minor
 |            radius. If all of the input arguments are scalar, then a scalar
 |            is returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `roa`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single r/a value at R_mid=0.6m, t=0.26s::
 |          
 |              roa_val = Eq_instance.rmid2roa(0.6, 0.26)
 |          
 |          Find roa values at R_mid points 0.6m and 0.8m at the
 |          single time t=0.26s.::
 |          
 |              roa_arr = Eq_instance.rmid2roa([0.6, 0.8], 0.26)
 |          
 |          Find roa values at R_mid of 0.6m at times t=[0.2s, 0.3s]::
 |          
 |              roa_arr = Eq_instance.rmid2roa(0.6, [0.2, 0.3])
 |          
 |          Find r/a values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              roa_arr = Eq_instance.rmid2roa([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22vv(self, R_mid, t, **kwargs)
 |      Calculates the flux surface volume corresponding to the passed R_mid (mapped outboard midplane major radius) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to v.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of v. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |      
 |      Returns:
 |          `v` or (`v`, `time_idxs`)
 |          
 |          * **v** (`Array or scalar float`) - The flux surface volume.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `v`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single v value for Rmid=0.7m, t=0.26s::
 |          
 |              v_val = Eq_instance.rmid2v(0.7, 0.26)
 |          
 |          Find v values at R_mid values of 0.5m and 0.7m at the single time
 |          t=0.26s::
 |          
 |              v_arr = Eq_instance.rmid2v([0.5, 0.7], 0.26)
 |          
 |          Find v values at R_mid=0.5m at times t=[0.2s, 0.3s]::
 |          
 |              v_arr = Eq_instance.rmid2v(0.5, [0.2, 0.3])
 |          
 |          Find v values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              v_arr = Eq_instance.rmid2v([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrmmiidd22vvoollnnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized flux surface volume.
 |      
 |      Based on the IDL version efit_rz2rho.pro by Steve Wolfe.
 |      
 |      Args:
 |          R_mid (Array-like or scalar float): Values of the outboard midplane
 |              major radius to map to volnorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R_mid`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `R_mid`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of volnorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R_mid` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R_mid`
 |              or be a scalar. Default is True (evaluate ALL `R_mid` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `R_mid` is given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `volnorm` or (`volnorm`, `time_idxs`)
 |          
 |          * **volnorm** (`Array or scalar float`) - Normalized volume.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `volnorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single volnorm value at R_mid=0.6m, t=0.26s::
 |          
 |              vol_val = Eq_instance.rmid2volnorm(0.6, 0.26)
 |          
 |          Find volnorm values at R_mid points 0.6m and 0.8m at the single time
 |          t=0.26s::
 |          
 |              vol_arr = Eq_instance.rmid2volnorm([0.6, 0.8], 0.26)
 |          
 |          Find volnorm values at R_mid points 0.6m at times t=[0.2s, 0.3s]::
 |          
 |              vol_arr = Eq_instance.rmid2volnorm(0.6, [0.2, 0.3])
 |          
 |          Find volnorm values at (R_mid, t) points (0.6m, 0.2s) and (0.5m, 0.3s)::
 |          
 |              vol_arr = Eq_instance.rmid2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22FF(self, roa, t, **kwargs)
 |      Convert the passed (r/a, t) coordinates into the flux function :math:`F=RB_{\phi}`.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to F.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of F. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`F`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `F` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `F`).
 |              
 |      Returns:
 |          `F` or (`F`, `time_idxs`)
 |          
 |          * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `F`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single F value at r/a=0.6, t=0.26s::
 |          
 |              F_val = Eq_instance.roa2F(0.6, 0.26)
 |          
 |          Find F values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              F_arr = Eq_instance.roa2F([0.6, 0.8], 0.26)
 |          
 |          Find F values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              F_arr = Eq_instance.roa2F(0.6, [0.2, 0.3])
 |          
 |          Find F values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              F_arr = Eq_instance.roa2F([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22FFFFPPrriimmee(self, roa, t, **kwargs)
 |      Convert the passed (r/a, t) coordinates into the flux function :math:`FF'`.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to FFPrime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of FFPrime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`FFPrime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `FFPrime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `FFPrime`).
 |              
 |      Returns:
 |          `FFPrime` or (`FFPrime`, `time_idxs`)
 |          
 |          * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF'`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `FFPrime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single FFPrime value at r/a=0.6, t=0.26s::
 |          
 |              FFPrime_val = Eq_instance.roa2FFPrime(0.6, 0.26)
 |          
 |          Find FFPrime values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              FFPrime_arr = Eq_instance.roa2FFPrime([0.6, 0.8], 0.26)
 |          
 |          Find FFPrime values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              FFPrime_arr = Eq_instance.roa2FFPrime(0.6, [0.2, 0.3])
 |          
 |          Find FFPrime values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              FFPrime_arr = Eq_instance.roa2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22pp(self, roa, t, **kwargs)
 |      Convert the passed (r/a, t) coordinates into pressure.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to p.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of p. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |              
 |      Returns:
 |          `p` or (`p`, `time_idxs`)
 |          
 |          * **p** (`Array or scalar float`) - The pressure. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `p`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single p value at r/a=0.6, t=0.26s::
 |          
 |              p_val = Eq_instance.roa2p(0.6, 0.26)
 |          
 |          Find p values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              p_arr = Eq_instance.roa2p([0.6, 0.8], 0.26)
 |          
 |          Find p values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              p_arr = Eq_instance.roa2p(0.6, [0.2, 0.3])
 |          
 |          Find p values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              p_arr = Eq_instance.roa2p([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22pphhiinnoorrmm(self, *args, **kwargs)
 |      Convert the passed (r/a, t) coordinates into phinorm.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to phinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of phinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |              
 |      Returns:
 |          `phinorm` or (`phinorm`, `time_idxs`)
 |          
 |          * **phinorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `phinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single phinorm value at r/a=0.6, t=0.26s::
 |          
 |              phinorm_val = Eq_instance.roa2phinorm(0.6, 0.26)
 |          
 |          Find phinorm values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              phinorm_arr = Eq_instance.roa2phinorm([0.6, 0.8], 0.26)
 |          
 |          Find phinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              phinorm_arr = Eq_instance.roa2phinorm(0.6, [0.2, 0.3])
 |          
 |          Find phinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              phinorm_arr = Eq_instance.roa2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22pppprriimmee(self, roa, t, **kwargs)
 |      Convert the passed (r/a, t) coordinates into pressure gradient.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to pprime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of pprime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`pprime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `pprime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `pprime`).
 |              
 |      Returns:
 |          `pprime` or (`pprime`, `time_idxs`)
 |          
 |          * **pprime** (`Array or scalar float`) - The pressure gradient. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `pprime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single pprime value at r/a=0.6, t=0.26s::
 |          
 |              pprime_val = Eq_instance.roa2pprime(0.6, 0.26)
 |          
 |          Find pprime values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              pprime_arr = Eq_instance.roa2pprime([0.6, 0.8], 0.26)
 |          
 |          Find pprime values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              pprime_arr = Eq_instance.roa2pprime(0.6, [0.2, 0.3])
 |          
 |          Find pprime values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              pprime_arr = Eq_instance.roa2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22ppssiinnoorrmm(self, *args, **kwargs)
 |      Convert the passed (r/a, t) coordinates into psinorm.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to psinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of psinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |              
 |      Returns:
 |          `psinorm` or (`psinorm`, `time_idxs`)
 |          
 |          * **psinorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `psinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at r/a=0.6, t=0.26s::
 |          
 |              psinorm_val = Eq_instance.roa2psinorm(0.6, 0.26)
 |          
 |          Find psinorm values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              psinorm_arr = Eq_instance.roa2psinorm([0.6, 0.8], 0.26)
 |          
 |          Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              psinorm_arr = Eq_instance.roa2psinorm(0.6, [0.2, 0.3])
 |          
 |          Find psinorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              psinorm_arr = Eq_instance.roa2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22qq(self, roa, t, **kwargs)
 |      Convert the passed (r/a, t) coordinates into safety factor ("q").
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to q.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of q. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`q`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `q` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `q`).
 |              
 |      Returns:
 |          `q` or (`q`, `time_idxs`)
 |          
 |          * **q** (`Array or scalar float`) - The safety factor ("q"). If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `q`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single q value at r/a=0.6, t=0.26s::
 |          
 |              q_val = Eq_instance.roa2q(0.6, 0.26)
 |          
 |          Find q values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              q_arr = Eq_instance.roa2q([0.6, 0.8], 0.26)
 |          
 |          Find q values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              q_arr = Eq_instance.roa2q(0.6, [0.2, 0.3])
 |          
 |          Find q values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              q_arr = Eq_instance.roa2q([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22rrhhoo(self, method, *args, **kwargs)
 |      Convert the passed (r/a, t) coordinates into one of several coordinates.
 |      
 |      Args:
 |          method (String): Indicates which coordinates to convert to.
 |              Valid options are:
 |              
 |                  ======= =================================
 |                  psinorm Normalized poloidal flux
 |                  phinorm Normalized toroidal flux
 |                  volnorm Normalized volume
 |                  Rmid    Midplane major radius
 |                  q       Safety factor
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to rho.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of rho. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |          
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at r/a=0.6, t=0.26s::
 |          
 |              psi_val = Eq_instance.roa2rho('psinorm', 0.6, 0.26)
 |          
 |          Find psinorm values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s::
 |          
 |              psi_arr = Eq_instance.roa2rho('psinorm', [0.6, 0.8], 0.26)
 |          
 |          Find psinorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.roa2rho('psinorm', 0.6, [0.2, 0.3])
 |          
 |          Find psinorm values at (r/a, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              psi_arr = Eq_instance.roa2rho('psinorm', [0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22rrmmiidd(self, roa, t, each_t=True, return_t=False, blob=None, length_unit=1)
 |      Convert the passed (r/a, t) coordinates into Rmid.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to Rmid.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).            
 |      
 |      Returns:
 |          `Rmid` or (`Rmid`, `time_idxs`)
 |      
 |          * **Rmid** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `Rmid`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single R_mid value at r/a=0.6, t=0.26s::
 |          
 |              R_mid_val = Eq_instance.roa2rmid(0.6, 0.26)
 |          
 |          Find R_mid values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              R_mid_arr = Eq_instance.roa2rmid([0.6, 0.8], 0.26)
 |          
 |          Find R_mid values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              R_mid_arr = Eq_instance.roa2rmid(0.6, [0.2, 0.3])
 |          
 |          Find R_mid values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              R_mid_arr = Eq_instance.roa2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22vv(self, roa, t, **kwargs)
 |      Convert the passed (r/a, t) coordinates into flux surface volume.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to v.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of v. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`v`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `v` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `v`).
 |              
 |      Returns:
 |          `v` or (`v`, `time_idxs`)
 |          
 |          * **v** (`Array or scalar float`) - The flux surface volume. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `v`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single v value at r/a=0.6, t=0.26s::
 |          
 |              v_val = Eq_instance.roa2v(0.6, 0.26)
 |          
 |          Find v values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              v_arr = Eq_instance.roa2v([0.6, 0.8], 0.26)
 |          
 |          Find v values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              v_arr = Eq_instance.roa2v(0.6, [0.2, 0.3])
 |          
 |          Find v values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              v_arr = Eq_instance.roa2v([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrooaa22vvoollnnoorrmm(self, *args, **kwargs)
 |      Convert the passed (r/a, t) coordinates into volnorm.
 |      
 |      Args:
 |          roa (Array-like or scalar float): Values of the normalized minor
 |              radius to map to volnorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `roa`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `roa`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of volnorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `roa` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `roa`
 |              or be a scalar. Default is True (evaluate ALL `roa` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |              
 |      Returns:
 |          `volnorm` or (`volnorm`, `time_idxs`)
 |          
 |          * **volnorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `volnorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single volnorm value at r/a=0.6, t=0.26s::
 |          
 |              volnorm_val = Eq_instance.roa2volnorm(0.6, 0.26)
 |          
 |          Find volnorm values at r/a points 0.6 and 0.8 at the
 |          single time t=0.26s.::
 |          
 |              volnorm_arr = Eq_instance.roa2volnorm([0.6, 0.8], 0.26)
 |          
 |          Find volnorm values at r/a of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              volnorm_arr = Eq_instance.roa2volnorm(0.6, [0.2, 0.3])
 |          
 |          Find volnorm values at (roa, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              volnorm_arr = Eq_instance.roa2volnorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  rrzz22BB(self, R, Z, t, **kwargs)
 |      Calculates the magnitude of the magnetic field at the given (R, Z, t).
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to B. If `R` and `Z` are both scalar values, they are used
 |              as the coordinate pair for all of the values in `t`. Must have
 |              the same shape as `Z` unless the `make_grid` keyword is set. If
 |              the `make_grid` keyword is True, `R` must have exactly one
 |              dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to B. If `R` and `Z` are both scalar values, they are used
 |              as the coordinate pair for all of the values in `t`. Must have
 |              the same shape as `R` unless the `make_grid` keyword is set. If
 |              the `make_grid` keyword is True, `Z` must have exactly one
 |              dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`B`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `B` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `B`).
 |      
 |      Returns:
 |          `B` or (`B`, `time_idxs`)
 |          
 |          * **B** (`Array or scalar float`) - The magnitude of the magnetic
 |            field. If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `B` has this shape as well, unless
 |            the `make_grid` keyword was True, in which case `B` has shape
 |            (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `B`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single B value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              B_val = Eq_instance.rz2B(0.6, 0, 0.26)
 |          
 |          Find B values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              B_arr = Eq_instance.rz2B([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find B values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              B_arr = Eq_instance.rz2B(0.6, 0, [0.2, 0.3])
 |          
 |          Find B values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              B_arr = Eq_instance.rz2B([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find B values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              B_mat = Eq_instance.rz2B(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22BBRR(self, R, Z, t, return_t=False, make_grid=False, each_t=True, length_unit=1)
 |      Calculates the major radial component of the magnetic field at the given (R, Z, t) coordinates.
 |      
 |      Uses
 |      
 |      .. math::
 |          
 |          B_R = -\frac{1}{R}\frac{\partial \psi}{\partial Z}
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to radial field. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to radial field. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |                  
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`BR`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `BR` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `BR`).
 |      
 |      Returns:
 |          `BR` or (`BR`, `time_idxs`)
 |      
 |          * **BR** (`Array or scalar float`) - The major radial component of
 |            the magnetic field. If all of the input arguments are scalar, then
 |            a scalar is returned. Otherwise, a scipy Array is returned. If `R`
 |            and `Z` both have the same shape then `BR` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `BR` has
 |            shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `BR`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single BR value at R=0.6m, Z=0.0m, t=0.26s::
 |              
 |              BR_val = Eq_instance.rz2BR(0.6, 0, 0.26)
 |          
 |          Find BR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |              
 |              BR_arr = Eq_instance.rz2BR([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find BR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |              
 |              BR_arr = Eq_instance.rz2BR(0.6, 0, [0.2, 0.3])
 |          
 |          Find BR values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |              
 |              BR_arr = Eq_instance.rz2BR([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find BR values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |              
 |              BR_mat = Eq_instance.rz2BR(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22BBTT(self, R, Z, t, **kwargs)
 |      Calculates the toroidal component of the magnetic field at the given (R, Z, t).
 |      
 |      Uses :math:`B_\phi = F / R`.
 |      
 |      By default, EFIT only computes this inside the LCFS. To approximate the
 |      field outside of the LCFS, :math:`B_\phi \approx B_{t, vac} R_0 / R` is
 |      used, where :math:`B_{t, vac}` is obtained with :py:meth:`getBtVac` and
 |      :math:`R_0` is the major radius of the magnetic axis obtained from
 |      :py:meth:`getMagR`.
 |      
 |      The coordinate system used is right-handed, such that "forward" field on
 |      Alcator C-Mod (clockwise when seen from above) has negative BT.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to BT. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to BT. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`BT`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `BT` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `BT`).
 |      
 |      Returns:
 |          `BT` or (`BT`, `time_idxs`)
 |          
 |          * **BT** (`Array or scalar float`) - The toroidal magnetic field.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `BT` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `BT`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `BT`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single BT value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              BT_val = Eq_instance.rz2BT(0.6, 0, 0.26)
 |          
 |          Find BT values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              BT_arr = Eq_instance.rz2BT([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find BT values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              BT_arr = Eq_instance.rz2BT(0.6, 0, [0.2, 0.3])
 |          
 |          Find BT values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              BT_arr = Eq_instance.rz2BT([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find BT values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              BT_mat = Eq_instance.rz2BT(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22BBZZ(self, R, Z, t, return_t=False, make_grid=False, each_t=True, length_unit=1)
 |      Calculates the vertical component of the magnetic field at the given (R, Z, t) coordinates.
 |      
 |      Uses
 |      
 |      .. math::
 |          
 |          B_Z = \frac{1}{R}\frac{\partial \psi}{\partial R}
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to vertical field. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to vertical field. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |                  
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`BZ`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `BZ` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `BZ`).
 |      
 |      Returns:
 |          `BZ` or (`BZ`, `time_idxs`)
 |          
 |          * **BZ** (`Array or scalar float`) - The vertical component of the
 |            magnetic field. If all of the input arguments are scalar, then a
 |            scalar is returned. Otherwise, a scipy Array is returned. If `R`
 |            and `Z` both have the same shape then `BZ` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `BZ` has
 |            shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `BZ`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single BZ value at R=0.6m, Z=0.0m, t=0.26s::
 |              
 |              BZ_val = Eq_instance.rz2BZ(0.6, 0, 0.26)
 |          
 |          Find BZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |              
 |              BZ_arr = Eq_instance.rz2BZ([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find BZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |              
 |              BZ_arr = Eq_instance.rz2BZ(0.6, 0, [0.2, 0.3])
 |          
 |          Find BZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |              
 |              BZ_arr = Eq_instance.rz2BZ([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find BZ values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |              
 |              BZ_mat = Eq_instance.rz2BZ(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22FF(self, R, Z, t, **kwargs)
 |      Calculates the flux function :math:`F=RB_{\phi}` at the given (R, Z, t).
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to F. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to F. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of F. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`F`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `F` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `F`).
 |      
 |      Returns:
 |          `F` or (`F`, `time_idxs`)
 |          
 |          * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `F` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `F`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `F`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single F value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              F_val = Eq_instance.rz2F(0.6, 0, 0.26)
 |          
 |          Find F values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              F_arr = Eq_instance.rz2F([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find F values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              F_arr = Eq_instance.rz2F(0.6, 0, [0.2, 0.3])
 |          
 |          Find F values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              F_arr = Eq_instance.rz2F([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find F values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              F_mat = Eq_instance.rz2F(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22FFFFPPrriimmee(self, R, Z, t, **kwargs)
 |      Calculates the flux function :math:`FF'` at the given (R, Z, t).
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to FFPrime. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to FFPrime. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of FFPrime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`FFPrime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `FFPrime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `FFPrime`).
 |      
 |      Returns:
 |          `FFPrime` or (`FFPrime`, `time_idxs`)
 |          
 |          * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF'`.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `FFPrime` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `FFPrime`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `FFPrime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single FFPrime value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              FFPrime_val = Eq_instance.rz2FFPrime(0.6, 0, 0.26)
 |          
 |          Find FFPrime values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              FFPrime_arr = Eq_instance.rz2FFPrime([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find FFPrime values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              FFPrime_arr = Eq_instance.rz2FFPrime(0.6, 0, [0.2, 0.3])
 |          
 |          Find FFPrime values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              FFPrime_arr = Eq_instance.rz2FFPrime([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find FFPrime values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              FFPrime_mat = Eq_instance.rz2FFPrime(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22FFiieellddLLiinneeTTrraaccee(self, R0, Z0, t, phi0=0.0, field='B', num_rev=1.0, rev_method='toroidal', dphi=0.062831853071795868, integrator='dopri5')
 |      Trace a field line starting from a given (R, phi, Z) point.
 |      
 |      Args:
 |          R0 (float): Major radial coordinate of starting point.
 |          Z0 (float): Vertical coordinate of starting point.
 |          t (float): Time to trace field line at.
 |      
 |      Keyword Args:
 |          phi0 (float): Toroidal angle of starting point in radians. Default
 |              is 0.0.
 |          field ({'B', 'j'}): The field to use. Can be magnetic field ('B') or
 |              current density ('j'). Default is 'B' (magnetic field).
 |          num_rev (float): The number of revolutions to trace the field line
 |              through. Whether this refers to toroidal or poloidal revolutions
 |              is determined by the `rev_method` keyword. Default is 1.0.
 |          rev_method ('toroidal', 'poloidal'): Whether `num_rev` refers to the
 |              number of toroidal or poloidal revolutions the field line should
 |              make. Note that 'poloidal' only makes sense for close field
 |              lines. Default is 'toroidal'.
 |          dphi (float): Toroidal step size, in radians. Default is 0.02*pi.
 |              The number of steps taken is then 2*pi times the number of
 |              toroidal rotations divided by dphi. This can be negative to
 |              trace a field line clockwise instead of counterclockwise.
 |          integrator (str): The integrator to use with
 |              :py:class:`scipy.integrate.ode`. Default is 'dopri5' (explicit
 |              Dormand-Prince of order (4)5). Can also be an instance of
 |              :py:class:`scipy.integrate.ode` for which the integrator and its
 |              options has been set.
 |      
 |      Returns:
 |          array, (`nsteps` + 1, 3): Containing the (R, Z, phi) coordinates.
 |  
 |  rrzz22jj(self, R, Z, t, **kwargs)
 |      Calculates the magnitude of the current density at the given (R, Z, t) coordinates.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to current density magnitude. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `Z` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `R` must have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to current density magnitude. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `R` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `Z` must have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |                  
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`j`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `j` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `j`).
 |      
 |      Returns:
 |          `j` or (`j`, `time_idxs`)
 |          
 |          * **j** (`Array or scalar float`) - The magnitude of the current
 |            density. If all of the input arguments are scalar, then a scalar
 |            is returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `j` has this shape as well, unless
 |            the `make_grid` keyword was True, in which case `j` has shape
 |            (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `j`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single j value at R=0.6m, Z=0.0m, t=0.26s::
 |              
 |              j_val = Eq_instance.rz2j(0.6, 0, 0.26)
 |          
 |          Find j values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |              
 |              j_arr = Eq_instance.rz2j([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find j values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |              
 |              j_arr = Eq_instance.rz2j(0.6, 0, [0.2, 0.3])
 |          
 |          Find j values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |              
 |              j_arr = Eq_instance.rz2j([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find j values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |              
 |              j_mat = Eq_instance.rz2j(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22jjRR(self, R, Z, t, **kwargs)
 |      Calculates the major radial component of the current density at the given (R, Z, t) coordinates.
 |      
 |      .. math::
 |          
 |          j_R = -\frac{1}{\mu_0 R}F'\frac{\partial \psi}{\partial Z} = \frac{F' B_R}{\mu_0}
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to radial current density. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `Z` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `R` must have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to radial current density. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `R` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `Z` must have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |                  
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`jR`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `jR` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `jR`).
 |      
 |      Returns:
 |          `jR` or (`jR`, `time_idxs`)
 |      
 |          * **jR** (`Array or scalar float`) - The major radial component of
 |            the current density. If all of the input arguments are scalar, then
 |            a scalar is returned. Otherwise, a scipy Array is returned. If `R`
 |            and `Z` both have the same shape then `jR` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `jR` has
 |            shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `jR`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single jR value at R=0.6m, Z=0.0m, t=0.26s::
 |              
 |              jR_val = Eq_instance.rz2jR(0.6, 0, 0.26)
 |          
 |          Find jR values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |              
 |              jR_arr = Eq_instance.rz2jR([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find jR values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |              
 |              jR_arr = Eq_instance.rz2jR(0.6, 0, [0.2, 0.3])
 |          
 |          Find jR values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |              
 |              jR_arr = Eq_instance.rz2jR([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find jR values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |              
 |              jR_mat = Eq_instance.rz2jR(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22jjTT(self, R, Z, t, **kwargs)
 |      Calculates the toroidal component of the current density at the given (R, Z, t) coordinates.
 |      
 |      Uses
 |      
 |      .. math::
 |          
 |          j_\phi = Rp' + \frac{FF'}{\mu_0 R}
 |      
 |      The coordinate system used is right-handed, such that "forward" field on
 |      Alcator C-Mod (clockwise when seen from above) has negative jT.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to toroidal current density. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `Z` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `R` must have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to toroidal current density. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `R` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `Z` must have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |                  
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`jT`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `jT` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `jT`).
 |      
 |      Returns:
 |          `jT` or (`jT`, `time_idxs`)
 |          
 |          * **jT** (`Array or scalar float`) - The major radial component of
 |            the current density. If all of the input arguments are scalar,
 |            then a scalar is returned. Otherwise, a scipy Array is returned.
 |            If `R` and `Z` both have the same shape then `jT` has this shape
 |            as well, unless the `make_grid` keyword was True, in which case
 |            `jT` has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `jT`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single jT value at R=0.6m, Z=0.0m, t=0.26s::
 |              
 |              jT_val = Eq_instance.rz2jT(0.6, 0, 0.26)
 |          
 |          Find jT values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |              
 |              jT_arr = Eq_instance.rz2jT([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find jT values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |              
 |              jT_arr = Eq_instance.rz2jT(0.6, 0, [0.2, 0.3])
 |          
 |          Find jT values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |              
 |              jT_arr = Eq_instance.rz2jT([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find jT values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |              
 |              jT_mat = Eq_instance.rz2jT(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22jjZZ(self, R, Z, t, **kwargs)
 |      Calculates the vertical component of the current density at the given (R, Z, t) coordinates.
 |      
 |      Uses
 |      
 |      .. math::
 |          
 |          j_Z = \frac{1}{\mu_0 R}F'\frac{\partial \psi}{\partial R} = \frac{F' B_Z}{\mu_0}
 |      
 |      Note that this function includes a factor of -1 to correct the FF' from
 |      Alcator C-Mod's EFIT implementation. You should check the sign of your
 |      data.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to vertical current density. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `Z` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `R` must have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to vertical current density. If `R` and `Z` are both scalar
 |              values, they are used as the coordinate pair for all of the
 |              values in `t`. Must have the same shape as `R` unless the
 |              `make_grid` keyword is set. If the `make_grid` keyword is True,
 |              `Z` must have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |                  
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`jZ`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `jZ` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `jZ`).
 |      
 |      Returns:
 |          `jZ` or (`jZ`, `time_idxs`)
 |          
 |          * **jZ** (`Array or scalar float`) - The vertical component of the
 |            current density. If all of the input arguments are scalar, then a
 |            scalar is returned. Otherwise, a scipy Array is returned. If `R`
 |            and `Z` both have the same shape then `jZ` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `jZ` has
 |            shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `jZ`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single jZ value at R=0.6m, Z=0.0m, t=0.26s::
 |              
 |              jZ_val = Eq_instance.rz2jZ(0.6, 0, 0.26)
 |          
 |          Find jZ values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |              
 |              jZ_arr = Eq_instance.rz2jZ([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find jZ values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |              
 |              jZ_arr = Eq_instance.rz2jZ(0.6, 0, [0.2, 0.3])
 |          
 |          Find jZ values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |              
 |              jZ_arr = Eq_instance.rz2jZ([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find jZ values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |              
 |              jZ_mat = Eq_instance.rz2jZ(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22pp(self, R, Z, t, **kwargs)
 |      Calculates the pressure at the given (R, Z, t).
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to p. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to p. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of p. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |      
 |      Returns:
 |          `p` or (`p`, `time_idxs`)
 |          
 |          * **p** (`Array or scalar float`) - The pressure. If all
 |            of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `p` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `p`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `p`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single p value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              p_val = Eq_instance.rz2p(0.6, 0, 0.26)
 |          
 |          Find p values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              p_arr = Eq_instance.rz2p([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find p values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              p_arr = Eq_instance.rz2p(0.6, 0, [0.2, 0.3])
 |          
 |          Find p values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              p_arr = Eq_instance.rz2p([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find p values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              p_mat = Eq_instance.rz2p(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22pphhiinnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized toroidal flux.
 |      
 |      Uses the definitions:
 |      
 |      .. math::
 |      
 |          \texttt{phi} &= \int q(\psi)\,d\psi\\
 |          \texttt{phi\_norm} &= \frac{\phi}{\phi(a)}
 |      
 |      This is based on the IDL version efit_rz2rho.pro by Steve Wolfe.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to phinorm. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to phinorm. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of phinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting psinorm to phinorm.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `phinorm` or (`phinorm`, `time_idxs`)
 |          
 |          * **phinorm** (`Array or scalar float`) - The normalized toroidal
 |            flux. If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `phinorm` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `phinorm`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `phinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single phinorm value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              phi_val = Eq_instance.rz2phinorm(0.6, 0, 0.26)
 |          
 |          Find phinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              phi_arr = Eq_instance.rz2phinorm([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find phinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              phi_arr = Eq_instance.rz2phinorm(0.6, 0, [0.2, 0.3])
 |          
 |          Find phinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              phi_arr = Eq_instance.rz2phinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find phinorm values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              phi_mat = Eq_instance.rz2phinorm(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22pppprriimmee(self, R, Z, t, **kwargs)
 |      Calculates the pressure gradient at the given (R, Z, t).
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to pprime. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to pprime. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of pprime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`pprime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `pprime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `pprime`).
 |      
 |      Returns:
 |          `pprime` or (`pprime`, `time_idxs`)
 |          
 |          * **pprime** (`Array or scalar float`) - The pressure gradient. If
 |            all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `p` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `p`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `pprime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single pprime value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              pprime_val = Eq_instance.rz2pprime(0.6, 0, 0.26)
 |          
 |          Find pprime values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              pprime_arr = Eq_instance.rz2pprime([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find pprime values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              pprime_arr = Eq_instance.rz2pprime(0.6, 0, [0.2, 0.3])
 |          
 |          Find pprime values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              pprime_arr = Eq_instance.rz2pprime([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find pprime values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              pprime_mat = Eq_instance.rz2pprime(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22ppssii(self, R, Z, t, return_t=False, make_grid=False, each_t=True, length_unit=1)
 |      Converts the passed R, Z, t arrays to psi (unnormalized poloidal flux) values.
 |      
 |      What is usually returned by EFIT is the stream function,
 |      :math:`\psi=\psi_p/(2\pi)` which has units of Wb/rad.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to poloidal flux. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to poloidal flux. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `psi` or (`psi`, `time_idxs`)
 |          
 |          * **psi** (`Array or scalar float`) - The unnormalized poloidal
 |            flux. If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `psi` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `psi` has
 |            shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `psi`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psi value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              psi_val = Eq_instance.rz2psi(0.6, 0, 0.26)
 |          
 |          Find psi values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully
 |          specified, even if the values are all the same::
 |          
 |              psi_arr = Eq_instance.rz2psi([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find psi values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.rz2psi(0.6, 0, [0.2, 0.3])
 |          
 |          Find psi values at (R, Z, t) points (0.6m, 0m, 0.2s) and
 |          (0.5m, 0.2m, 0.3s)::
 |          
 |              psi_arr = Eq_instance.rz2psi([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find psi values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              psi_mat = Eq_instance.rz2psi(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22ppssiinnoorrmm(self, R, Z, t, return_t=False, sqrt=False, make_grid=False, each_t=True, length_unit=1)
 |      Calculates the normalized poloidal flux at the given (R, Z, t).
 |      
 |      Uses the definition:
 |      
 |      .. math::
 |      
 |          \texttt{psi\_norm} = \frac{\psi - \psi(0)}{\psi(a) - \psi(0)}
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to psinorm. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to psinorm. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of psinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `psinorm` or (`psinorm`, `time_idxs`)
 |          
 |          * **psinorm** (`Array or scalar float`) - The normalized poloidal
 |            flux. If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `psinorm` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `psinorm`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `psinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              psi_val = Eq_instance.rz2psinorm(0.6, 0, 0.26)
 |          
 |          Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              psi_arr = Eq_instance.rz2psinorm([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.rz2psinorm(0.6, 0, [0.2, 0.3])
 |          
 |          Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              psi_arr = Eq_instance.rz2psinorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find psinorm values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              psi_mat = Eq_instance.rz2psinorm(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22qq(self, R, Z, t, **kwargs)
 |      Calculates the safety factor ("q") at the given (R, Z, t).
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to q. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to q. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of q. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`q`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `q` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `q`).
 |      
 |      Returns:
 |          `q` or (`q`, `time_idxs`)
 |          
 |          * **q** (`Array or scalar float`) - The safety factor ("q"). If all
 |            of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `q` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `q`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `q`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single q value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              q_val = Eq_instance.rz2q(0.6, 0, 0.26)
 |          
 |          Find q values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              q_arr = Eq_instance.rz2q([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find q values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              q_arr = Eq_instance.rz2q(0.6, 0, [0.2, 0.3])
 |          
 |          Find q values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              q_arr = Eq_instance.rz2q([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find q values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              q_mat = Eq_instance.rz2q(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22rrhhoo(self, method, *args, **kwargs)
 |      Convert the passed (R, Z, t) coordinates into one of several coordinates.
 |      
 |      Args:
 |          method (String): Indicates which coordinates to convert to. Valid
 |              options are:
 |              
 |                  ======= =================================
 |                  psinorm Normalized poloidal flux
 |                  phinorm Normalized toroidal flux
 |                  volnorm Normalized volume
 |                  Rmid    Midplane major radius
 |                  r/a     Normalized minor radius
 |                  q       Safety factor
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to `rho`. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to `rho`. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of `rho`. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid when `destination` is Rmid. Default is False
 |              (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in,
 |              AND that `Rmid` is returned in. If a string is given, it must
 |              be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |          
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |          
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Raises:
 |          ValueError: If `method` is not one of the supported values.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              psi_val = Eq_instance.rz2rho('psinorm', 0.6, 0, 0.26)
 |          
 |          Find psinorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              psi_arr = Eq_instance.rz2rho('psinorm', [0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find psinorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.rz2rho('psinorm', 0.6, 0, [0.2, 0.3])
 |          
 |          Find psinorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              psi_arr = Eq_instance.rz2rho('psinorm', [0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find psinorm values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              psi_mat = Eq_instance.rz2rho('psinorm', R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22rrmmiidd(self, *args, **kwargs)
 |      Maps the given points to the outboard midplane major radius, Rmid.
 |      
 |      Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to Rmid. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to Rmid. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of Rmid. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in,
 |              AND that `Rmid` is returned in. If a string is given, it must
 |              be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting psinorm to Rmid.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `Rmid` or (`Rmid`, `time_idxs`)
 |          
 |          * **Rmid** (`Array or scalar float`) - The outboard midplan major
 |            radius. If all of the input arguments are scalar, then a scalar
 |            is returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `Rmid` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `Rmid`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `Rmid`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single Rmid value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              R_mid_val = Eq_instance.rz2rmid(0.6, 0, 0.26)
 |          
 |          Find R_mid values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              R_mid_arr = Eq_instance.rz2rmid([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find Rmid values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              R_mid_arr = Eq_instance.rz2rmid(0.6, 0, [0.2, 0.3])
 |          
 |          Find Rmid values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              R_mid_arr = Eq_instance.rz2rmid([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find Rmid values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              R_mid_mat = Eq_instance.rz2rmid(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22rrooaa(self, *args, **kwargs)
 |      Maps the given points to the normalized minor radius, r/a.
 |      
 |      Based on the IDL version efit_rz2rmid.pro by Steve Wolfe.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to r/a. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to r/a. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of r/a. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting psinorm to Rmid.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `roa` or (`roa`, `time_idxs`)
 |          
 |          * **roa** (`Array or scalar float`) - The normalized minor radius.
 |            If all of the input arguments are scalar, then a scalar
 |            is returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `roa` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `roa`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `roa`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single r/a value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              roa_val = Eq_instance.rz2roa(0.6, 0, 0.26)
 |          
 |          Find r/a values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the Z vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              roa_arr = Eq_instance.rz2roa([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find r/a values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              roa_arr = Eq_instance.rz2roa(0.6, 0, [0.2, 0.3])
 |          
 |          Find r/a values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              roa_arr = Eq_instance.rz2roa([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find r/a values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              roa_mat = Eq_instance.rz2roa(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22vv(self, R, Z, t, **kwargs)
 |      Calculates the flux surface volume at the given (R, Z, t).
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to v. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to v. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of v. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          return_t (Boolean): Set to True to return a tuple of (`v`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `v` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `v`).
 |      
 |      Returns:
 |          `v` or (`v`, `time_idxs`)
 |          
 |          * **v** (`Array or scalar float`) - The flux surface volume. If all
 |            of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `v` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `v`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `v`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the
 |          appropriate extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single v value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              v_val = Eq_instance.rz2v(0.6, 0, 0.26)
 |          
 |          Find v values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              v_arr = Eq_instance.rz2v([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find v values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              v_arr = Eq_instance.rz2v(0.6, 0, [0.2, 0.3])
 |          
 |          Find v values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              v_arr = Eq_instance.rz2v([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find v values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              v_mat = Eq_instance.rz2v(R, Z, 0.2, make_grid=True)
 |  
 |  rrzz22vvoollnnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized flux surface volume.
 |      
 |      Based on the IDL version efit_rz2rho.pro by Steve Wolfe.
 |      
 |      Args:
 |          R (Array-like or scalar float): Values of the radial coordinate to
 |              map to volnorm. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `Z` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `R` must
 |              have exactly one dimension.
 |          Z (Array-like or scalar float): Values of the vertical coordinate to
 |              map to volnorm. If `R` and `Z` are both scalar values,
 |              they are used as the coordinate pair for all of the values in
 |              `t`. Must have the same shape as `R` unless the `make_grid`
 |              keyword is set. If the `make_grid` keyword is True, `Z` must
 |              have exactly one dimension.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `R`, `Z`. If the `each_t` keyword is True, then `t` must be
 |              scalar or have exactly one dimension. If the `each_t` keyword is
 |              False, `t` must have the same shape as `R` and `Z` (or their
 |              meshgrid if `make_grid` is True).
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of volnorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `R`, `Z` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `R` and
 |              `Z` or be a scalar. Default is True (evaluate ALL `R`, `Z` at
 |              EACH element in `t`).
 |          make_grid (Boolean): Set to True to pass `R` and `Z` through
 |              :py:func:`scipy.meshgrid` before evaluating. If this is set to
 |              True, `R` and `Z` must each only have a single dimension, but
 |              can have different lengths. Default is False (do not form
 |              meshgrid).
 |          length_unit (String or 1): Length unit that `R`, `Z` are given in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting psinorm to volnorm.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `volnorm` or (`volnorm`, `time_idxs`)
 |          
 |          * **volnorm** (`Array or scalar float`) - The normalized volume.
 |            If all of the input arguments are scalar, then a scalar is
 |            returned. Otherwise, a scipy Array is returned. If `R` and `Z`
 |            both have the same shape then `volnorm` has this shape as well,
 |            unless the `make_grid` keyword was True, in which case `volnorm`
 |            has shape (len(`Z`), len(`R`)).
 |          * **time_idxs** (Array with same shape as `volnorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single volnorm value at R=0.6m, Z=0.0m, t=0.26s::
 |          
 |              psi_val = Eq_instance.rz2volnorm(0.6, 0, 0.26)
 |          
 |          Find volnorm values at (R, Z) points (0.6m, 0m) and (0.8m, 0m) at the
 |          single time t=0.26s. Note that the `Z` vector must be fully specified,
 |          even if the values are all the same::
 |          
 |              vol_arr = Eq_instance.rz2volnorm([0.6, 0.8], [0, 0], 0.26)
 |          
 |          Find volnorm values at (R, Z) points (0.6m, 0m) at times t=[0.2s, 0.3s]::
 |          
 |              vol_arr = Eq_instance.rz2volnorm(0.6, 0, [0.2, 0.3])
 |          
 |          Find volnorm values at (R, Z, t) points (0.6m, 0m, 0.2s) and (0.5m, 0.2m, 0.3s)::
 |          
 |              vol_arr = Eq_instance.rz2volnorm([0.6, 0.5], [0, 0.2], [0.2, 0.3], each_t=False)
 |          
 |          Find volnorm values on grid defined by 1D vector of radial positions `R`
 |          and 1D vector of vertical positions `Z` at time t=0.2s::
 |          
 |              vol_mat = Eq_instance.rz2volnorm(R, Z, 0.2, make_grid=True)
 |  
 |  vvoollnnoorrmm22FF(self, volnorm, t, **kwargs)
 |      Calculates the flux function :math:`F=RB_{\phi}` corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to F.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of F. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`F`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `F` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `F`).
 |      
 |      Returns:
 |          `F` or (`F`, `time_idxs`)
 |          
 |          * **F** (`Array or scalar float`) - The flux function :math:`F=RB_{\phi}`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `F`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single F value for volnorm=0.7, t=0.26s::
 |          
 |              F_val = Eq_instance.volnorm2F(0.7, 0.26)
 |          
 |          Find F values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              F_arr = Eq_instance.volnorm2F([0.5, 0.7], 0.26)
 |          
 |          Find F values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              F_arr = Eq_instance.volnorm2F(0.5, [0.2, 0.3])
 |          
 |          Find F values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              F_arr = Eq_instance.volnorm2F([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22FFFFPPrriimmee(self, volnorm, t, **kwargs)
 |      Calculates the flux function :math:`FF'` corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to FFPrime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of FFPrime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`FFPrime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `FFPrime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `FFPrime`).
 |      
 |      Returns:
 |          `FFPrime` or (`FFPrime`, `time_idxs`)
 |          
 |          * **FFPrime** (`Array or scalar float`) - The flux function :math:`FF'`.
 |            If all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `FFPrime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single FFPrime value for volnorm=0.7, t=0.26s::
 |          
 |              FFPrime_val = Eq_instance.volnorm2FFPrime(0.7, 0.26)
 |          
 |          Find FFPrime values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              FFPrime_arr = Eq_instance.volnorm2FFPrime([0.5, 0.7], 0.26)
 |          
 |          Find FFPrime values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              FFPrime_arr = Eq_instance.volnorm2FFPrime(0.5, [0.2, 0.3])
 |          
 |          Find FFPrime values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              FFPrime_arr = Eq_instance.volnorm2FFPrime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22pp(self, volnorm, t, **kwargs)
 |      Calculates the pressure corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to p.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of p. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`p`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `p` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `p`).
 |      
 |      Returns:
 |          `p` or (`p`, `time_idxs`)
 |          
 |          * **p** (`Array or scalar float`) - The pressure. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `p`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single p value for volnorm=0.7, t=0.26s::
 |          
 |              p_val = Eq_instance.volnorm2p(0.7, 0.26)
 |          
 |          Find p values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              p_arr = Eq_instance.volnorm2p([0.5, 0.7], 0.26)
 |          
 |          Find p values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              p_arr = Eq_instance.volnorm2p(0.5, [0.2, 0.3])
 |          
 |          Find p values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              p_arr = Eq_instance.volnorm2p([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22pphhiinnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized toroidal flux corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to phinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of phinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `phinorm` or (`phinorm`, `time_idxs`)
 |          
 |          * **phinorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `phinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single phinorm value for volnorm=0.7, t=0.26s::
 |          
 |              phinorm_val = Eq_instance.volnorm2phinorm(0.7, 0.26)
 |          
 |          Find phinorm values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              phinorm_arr = Eq_instance.volnorm2phinorm([0.5, 0.7], 0.26)
 |          
 |          Find phinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              phinorm_arr = Eq_instance.volnorm2phinorm(0.5, [0.2, 0.3])
 |          
 |          Find phinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              phinorm_arr = Eq_instance.volnorm2phinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22pppprriimmee(self, volnorm, t, **kwargs)
 |      Calculates the pressure gradient corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to pprime.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of pprime. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`pprime`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `pprime` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `pprime`).
 |      
 |      Returns:
 |          `pprime` or (`pprime`, `time_idxs`)
 |          
 |          * **pprime** (`Array or scalar float`) - The pressure gradient. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `pprime`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single pprime value for volnorm=0.7, t=0.26s::
 |          
 |              pprime_val = Eq_instance.volnorm2pprime(0.7, 0.26)
 |          
 |          Find pprime values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              pprime_arr = Eq_instance.volnorm2pprime([0.5, 0.7], 0.26)
 |          
 |          Find pprime values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              pprime_arr = Eq_instance.volnorm2pprime(0.5, [0.2, 0.3])
 |          
 |          Find pprime values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              pprime_arr = Eq_instance.volnorm2pprime([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22ppssiinnoorrmm(self, *args, **kwargs)
 |      Calculates the normalized poloidal flux corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to psinorm.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of psinorm. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `psinorm` or (`psinorm`, `time_idxs`)
 |          
 |          * **psinorm** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `psinorm`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value for volnorm=0.7, t=0.26s::
 |          
 |              psinorm_val = Eq_instance.volnorm2psinorm(0.7, 0.26)
 |          
 |          Find psinorm values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              psinorm_arr = Eq_instance.volnorm2psinorm([0.5, 0.7], 0.26)
 |          
 |          Find psinorm values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              psinorm_arr = Eq_instance.volnorm2psinorm(0.5, [0.2, 0.3])
 |          
 |          Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              psinorm_arr = Eq_instance.volnorm2psinorm([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22qq(self, volnorm, t, **kwargs)
 |      Calculates the safety factor ("q") corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to q.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of q. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`q`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `q` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `q`).
 |      
 |      Returns:
 |          `q` or (`q`, `time_idxs`)
 |          
 |          * **q** (`Array or scalar float`) - The safety factor ("q"). If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `q`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single q value for volnorm=0.7, t=0.26s::
 |          
 |              q_val = Eq_instance.volnorm2q(0.7, 0.26)
 |          
 |          Find q values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              q_arr = Eq_instance.volnorm2q([0.5, 0.7], 0.26)
 |          
 |          Find q values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              q_arr = Eq_instance.volnorm2q(0.5, [0.2, 0.3])
 |          
 |          Find q values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              q_arr = Eq_instance.volnorm2q([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22rrhhoo(self, method, *args, **kwargs)
 |      Convert the passed (volnorm, t) coordinates into one of several coordinates.
 |      
 |      Args:
 |          method (String): Indicates which coordinates to convert to.
 |              Valid options are:
 |              
 |                  ======= =================================
 |                  psinorm Normalized poloidal flux
 |                  phinorm Normalized toroidal flux
 |                  Rmid    Midplane major radius
 |                  r/a     Normalized minor radius
 |                  q       Safety factor
 |                  F       Flux function :math:`F=RB_{\phi}`
 |                  FFPrime Flux function :math:`FF'`
 |                  p       Pressure
 |                  pprime  Pressure gradient
 |                  v       Flux surface volume
 |                  ======= =================================
 |              
 |              Additionally, each valid option may be prepended with 'sqrt'
 |              to specify the square root of the desired unit.
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to rho.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of rho. Only
 |              the square root of positive values is taken. Negative values are
 |              replaced with zeros, consistent with Steve Wolfe's IDL
 |              implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated at
 |              each value in `t`. If True, `t` must have only one dimension (or
 |              be a scalar). If False, `t` must match the shape of `volnorm` or be
 |              a scalar. Default is True (evaluate ALL `volnorm` at EACH element in
 |              `t`).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).            
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `rho` or (`rho`, `time_idxs`)
 |          
 |          * **rho** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `rho`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Raises:
 |          ValueError: If `method` is not one of the supported values.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single psinorm value at volnorm=0.6, t=0.26s::
 |          
 |              psi_val = Eq_instance.volnorm2rho('psinorm', 0.6, 0.26)
 |          
 |          Find psinorm values at volnorm of 0.6 and 0.8 at the
 |          single time t=0.26s::
 |          
 |              psi_arr = Eq_instance.volnorm2rho('psinorm', [0.6, 0.8], 0.26)
 |          
 |          Find psinorm values at volnorm of 0.6 at times t=[0.2s, 0.3s]::
 |          
 |              psi_arr = Eq_instance.volnorm2rho('psinorm', 0.6, [0.2, 0.3])
 |          
 |          Find psinorm values at (volnorm, t) points (0.6, 0.2s) and (0.5m, 0.3s)::
 |          
 |              psi_arr = Eq_instance.volnorm2rho('psinorm', [0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22rrmmiidd(self, *args, **kwargs)
 |      Calculates the mapped outboard midplane major radius corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to Rmid.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of Rmid. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          rho (Boolean): Set to True to return r/a (normalized minor radius)
 |              instead of Rmid. Default is False (return major radius, Rmid).                        
 |          length_unit (String or 1): Length unit that `Rmid` is returned in.
 |              If a string is given, it must be a valid unit specifier:
 |              
 |                  ===========  ===========
 |                  'm'          meters
 |                  'cm'         centimeters
 |                  'mm'         millimeters
 |                  'in'         inches
 |                  'ft'         feet
 |                  'yd'         yards
 |                  'smoot'      smoots
 |                  'cubit'      cubits
 |                  'hand'       hands
 |                  'default'    meters
 |                  ===========  ===========
 |              
 |              If length_unit is 1 or None, meters are assumed. The default
 |              value is 1 (use meters).            
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `Rmid` or (`Rmid`, `time_idxs`)
 |          
 |          * **Rmid** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `Rmid`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single Rmid value for volnorm=0.7, t=0.26s::
 |          
 |              Rmid_val = Eq_instance.volnorm2rmid(0.7, 0.26)
 |          
 |          Find Rmid values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              Rmid_arr = Eq_instance.volnorm2rmid([0.5, 0.7], 0.26)
 |          
 |          Find Rmid values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              Rmid_arr = Eq_instance.volnorm2rmid(0.5, [0.2, 0.3])
 |          
 |          Find Rmid values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              Rmid_arr = Eq_instance.volnorm2rmid([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22rrooaa(self, *args, **kwargs)
 |      Calculates the normalized minor radius corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to r/a.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of r/a. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`rho`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `rho` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `rho`).
 |      
 |      Returns:
 |          `roa` or (`roa`, `time_idxs`)
 |          
 |          * **roa** (`Array or scalar float`) - The converted coordinates. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `roa`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single r/a value for volnorm=0.7, t=0.26s::
 |          
 |              roa_val = Eq_instance.volnorm2roa(0.7, 0.26)
 |          
 |          Find r/a values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              roa_arr = Eq_instance.volnorm2roa([0.5, 0.7], 0.26)
 |          
 |          Find r/a values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              roa_arr = Eq_instance.volnorm2roa(0.5, [0.2, 0.3])
 |          
 |          Find r/a values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              roa_arr = Eq_instance.volnorm2roa([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  vvoollnnoorrmm22vv(self, volnorm, t, **kwargs)
 |      Calculates the flux surface volume corresponding to the passed volnorm (normalized flux surface volume) values.
 |      
 |      By default, EFIT only computes this inside the LCFS.
 |      
 |      Args:
 |          volnorm (Array-like or scalar float): Values of the normalized
 |              flux surface volume to map to v.
 |          t (Array-like or scalar float): Times to perform the conversion at.
 |              If `t` is a single value, it is used for all of the elements of
 |              `volnorm`. If the `each_t` keyword is True, then `t` must be scalar
 |              or have exactly one dimension. If the `each_t` keyword is False,
 |              `t` must have the same shape as `volnorm`.
 |      
 |      Keyword Args:
 |          sqrt (Boolean): Set to True to return the square root of v. 
 |              Only the square root of positive values is taken. Negative 
 |              values are replaced with zeros, consistent with Steve Wolfe's
 |              IDL implementation efit_rz2rho.pro. Default is False.
 |          each_t (Boolean): When True, the elements in `volnorm` are evaluated 
 |              at each value in `t`. If True, `t` must have only one dimension
 |              (or be a scalar). If False, `t` must match the shape of `volnorm`
 |              or be a scalar. Default is True (evaluate ALL `volnorm` at EACH
 |              element in `t`).
 |          k (positive int): The degree of polynomial spline interpolation to
 |              use in converting coordinates.
 |          return_t (Boolean): Set to True to return a tuple of (`v`,
 |              `time_idxs`), where `time_idxs` is the array of time indices
 |              actually used in evaluating `v` with nearest-neighbor
 |              interpolation. (This is mostly present as an internal helper.)
 |              Default is False (only return `v`).
 |      
 |      Returns:
 |          `v` or (`v`, `time_idxs`)
 |          
 |          * **v** (`Array or scalar float`) - The flux surface volume. If
 |            all of the input arguments are scalar, then a scalar is returned.
 |            Otherwise, a scipy Array is returned.
 |          * **time_idxs** (Array with same shape as `v`) - The indices 
 |            (in :py:meth:`self.getTimeBase`) that were used for
 |            nearest-neighbor interpolation. Only returned if `return_t` is
 |            True.
 |      
 |      Examples:
 |          All assume that `Eq_instance` is a valid instance of the appropriate
 |          extension of the :py:class:`Equilibrium` abstract class.
 |          
 |          Find single v value for volnorm=0.7, t=0.26s::
 |          
 |              v_val = Eq_instance.volnorm2p(0.7, 0.26)
 |          
 |          Find v values at volnorm values of 0.5 and 0.7 at the single time
 |          t=0.26s::
 |          
 |              v_arr = Eq_instance.volnorm2v([0.5, 0.7], 0.26)
 |          
 |          Find v values at volnorm=0.5 at times t=[0.2s, 0.3s]::
 |          
 |              v_arr = Eq_instance.volnorm2v(0.5, [0.2, 0.3])
 |          
 |          Find v values at (volnorm, t) points (0.6, 0.2s) and (0.5, 0.3s)::
 |          
 |              v_arr = Eq_instance.volnorm2v([0.6, 0.5], [0.2, 0.3], each_t=False)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from eqtools.core.Equilibrium:
 |  
 |  ____ddiicctt____
 |      dictionary for instance variables (if defined)
 |  
 |  ____wweeaakkrreeff____
 |      list of weak references to the object (if defined)
